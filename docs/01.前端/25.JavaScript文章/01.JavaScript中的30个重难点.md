---
title: JavaScript中的30个重难点
date: 2021-10-25 22:20:39
permalink: /pages/8335d0/
categories:
  - 前端
  - JavaScript文章
tags:
  - 数据类型
  - 表达式运算符和分支结构
  - 内置对象
  - JS DOM
  - JS BOM
  - 函数对象★
  - 面向对象★
---
## 数据类型

### JS中有哪些数据类型

JavaScript 中的值都具有特定的类型。例如，字符串或数字。

在 JavaScript 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）。

- 原始类型(基本类型)
  - Number BigInt String Boolean（逻辑类型） null 值 undefined 值
- 引用类型(复杂类型)
  - object 类型和 symbol 类型

### typeof 和 instanceof 检测数据类型的异同

typeof返回值是一个字符串，该字符串说明运算数的类型,结果为number, boolean,string,function（函数），object(NULL,数组，对象），undefined

instanceof 是用来判断 A 是否为 B 的实例对象，检测的是原型

<code-group>
  <code-block title="typeof" active>
  ```js
  console.log(typeof 123); // number
  console.log(typeof true); // boolean
  console.log(typeof 'ioinn'); // string
  console.log(typeof undefined); // undefined

  console.log(typeof null); // object
    // 计算机typeof 返回的数据类型 机器码 01011:000 => object
    // null 0000000...000 => object
    // js bug

  console.log(typeof []); // object // 引用类型
  console.log(typeof new Date()); // object

  console.log(typeof {}); // object
  console.log(typeof function () {}); // function
  console.log(typeof Array); // function  // 为什么不是object类型
    // typeof 引用类型 object: object function
    // object 定义一个[[call]]: function object

  var str = 'ioinn';
  console.log('--------');
  console.log(str); // ioinn
  console.log(typeof str); // string
  console.log('--------');
  var str1 = new String('ioinn'); // 实例化后的对象
  console.log(str1); // {}
    // key : value
    // 0: "i"
    // 1: "o"
    // 2: "i"
    // 3: "n"
    // 4: "n"
  console.log(typeof str1); // object

    // typeof 少null 多function

  ```
  </code-block>

  <code-block title="instanceof">
  ```js
  // instanceof检测 boolean: true false
      // A instanceof B  A 是否是由 B 实例化出来的
    console.log([] instanceof Array); // true
    console.log({} instanceof Object); // true
    console.log(new Date() instanceof Date); // true
    function Person() {}
    console.log(new Person() instanceof Person); // true

    console.log([] instanceof Object); // true
    console.log(new Date() instanceof Object); // true
    console.log(new Person() instanceof Object); // true
      //instanceof 原型链 A instanceof B true,B instanceof c true

    if (typeof val !== undefined) {}
    console.log(Object.prototype.toString.call('1')); // [object String]
    console.log(Object.prototype.toString.call([])); // [object Array]
  ```

  </code-block>
</code-group>

### 深入理解数据的存储形式-堆栈

什么是栈:计算机为原始类型开辟的一 块内存空间 string number ...

什么是堆：计算机为引用类型开辟的一块内存空间 object

```js
var a = 'ioinn';
var b = a;
b = 'momo';
console.log(a, b); // ioinn momo

var c = { key: 1 };
var d = c;
d.key = 2;
console.log(c, d); // {key: 2} {key: 2}

// c d ['x00123','x00123'] -> {key: 2 }
// c d 'x00123' -> {key: 2 }  {key: 2 }
```

### 深浅拷贝有哪些方式

深拷贝与浅拷贝，简单来说

就是假如 B 复制了 A, 当修改 A 时, 看 B 是否会发生变化, 如果 B 也跟着变了, 说明这是 浅拷贝

如果 B 没变, 就是 深拷贝

```js
// 遍历
var obj = {
  a: 'hello',
  b: {
    a: 'world',
    b: 111,
  },
  c: [11, 'ioinn', 'momo'],
};
```

<code-group>
  <code-block title="浅拷贝" active>
  ```js
  // 浅拷贝
      objCopy;
      function simpleClone(objNew) {
        var obj = {};
        for (var i in objNew) {
          obj[i] = objNew[i];
        }
        return obj;
      }
      var objCopy = simpleClone(obj);
      //   objCopy.b.a = 'world111';
      console.log(obj);
      console.log(objCopy);

      //   Object.create() 复制到原型上
      var objCopyCreate = Object.create(obj);
      objCopy.b.a = 'world111';
      console.log(obj);
      console.log(objCopyCreate);

  ```
  </code-block>

  <code-block title="深拷贝">
  ```js
  // 深拷贝
      function deepClone(startObj, endObj) {
        var obj = endObj || {};
        for (var i in startObj) {
          if (typeof startObj[i] === 'object') {
            obj[i] = startObj[i].constructor === Array ? [] : {};
            deepClone(startObj[i], obj[i]);
          } else {
            obj[i] = startObj[i];
          }
        }
        return obj;
      }
      var objCopy = deepClone(obj);
      objCopy.b.a = 'world111';
      objCopy.c[0] = '22';
      console.log(obj); // "world" 11
      console.log(objCopy); // "world111" "22"

      // JSON.parse JSON.stringify
      var objCopy = JSON.parse(JSON.stringify(obj)); // object -> string -> object
      objCopy.b.a = 'world111';
      objCopy.c[0] = '22';
      console.log(obj); // "world" 11
      console.log(objCopy); // "world111" "22"
  ```

  </code-block>
</code-group>

### 开发中常见数据类型转换有哪些坑

特殊类型的隐式转换 NaN 0 undefined null '' -> 这五种类型会隐式转换为false  其他均为 true

```js
var val = 0;
if (!val) {
  // val 可能等于 NaN 0 undefined ...
} else {
}
var bool = Boolean(NaN);
console.log(bool); //false
```

逻辑运算符 && 和 || 在隐式转换下的情况

```js
console.log(true && true); // true false
console.log(true || true); // false true
console.log(0 && 5); // 0 true true
console.log(0 || 5); // 5 false true
// if方式 耗能较大
var a = 8;
if (a === 0) {
  console.log(a);
} else {
  console.log(1);
}
```

== 和 === 的区别

```js
console.log(undefined == null); // true 对比值 会进行隐式转换 0 == 0
console.log(undefined === null); //false 对比 值 和 类型 不会进转换
// 尽量使用 === 避免因隐式转换带来的不必要的错误 因为这是不易排查的
if (a !== b) {
  console.log();
}
```

## 表达式运算符和分支结构

### 运算符多的情况下需要注意哪些

[运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table)

```js
  // 优先级 +-*/ && || () -= -- ++
  // (1+2)(val || val2)

  // js舍入误差
console.log(0.1 + 0.2); //0.30000000000000004
// js 采用 IEEE754 二进制浮点数算术标准 进行存储
// 0.1 ->0001100110011001100110011001100110011001100110011001101
// 0.2 -> 0.001100110011001100110011001100110011001100110011001101
//   console.log((0.1).toString(2));
//   console.log((0.2).toString(2));
//   console.log((0.1 + 0.2).toString(2)); /0100110011001100110011001100110011001100110011001101

  // 解决方案1
console.log(parseFloat((0.1 + 0.2).toFixed(2))); // 0.3

  // 解决方案2
function add(num1, num2) {
  m = Math.pow(10, 2);
  return (num1 * m + num2 * m) / m;
}
console.log(add(0.1, 0.2));
```

### 开发中如何优化for循环

```js
  // for(){}
  // 性能优化
for (var i = 0; i < arr.length; i++) {
  // do something
}
for (var i = 0, len = arr.length; i < len; i++) {
  // do something
}

  // 算法
// 1 + 2 + 3 + 4 + ...... + 10000
for (var i = 1; i <= 10000; i++) {
  // sum += i;
}
//   100(100+1)/2 = 5050
//   ((startNum + endNum) * endNum) / 2;

  // leetCode 算法
```

## 内置对象

### js中常见的内置对象有哪些

```js
// 三种包装对象：String、Number、Boolean 构造函数转换为对象
      // 其他常用的标准内置对象：Array、Date、Function、Object...

      var str = 'ioinn';
      var str = new String('hello');
      //   {0:i,1:o,2:i,3:n,4:n}
      //   str.方法()
      {
        // var str = new String('hello');
        // var str1 = str.fangfa();
        // str = null;
        // console.log(str1);
      }
      //   var num = 1;
      //   var bool = true;
```

### 面试常见装箱和拆箱的理解

**装箱: 把基本数据类型转化为对应的引用数据类型的操作**

```js
var num = 123;
var objNum = new Number(123);
console.log(typeof num); // number
console.log(typeof objNum); // object
```

**拆箱: 将引用类型对象转换为对应的值类型对象**

```js
valueOf()
var objNum = new Number(123);
console.log(typeof objNum.valueOf(), objNum.valueOf()); // number 123
```

```js
// js toPrimitive(input,type) input:传入的值  type:值类型
```

input是输入的值，type 是期望转换的类型，他可以是字符串，也可以是数字。
如果转换的类型是number，会执行以下步骤：

1. 如果input是原始值，直接返回这个值；
2. 否则，如果input是对象，调用input.valueOf()，如果结果是原始值，返回结果；
3. 否则，调用input.toString() 如果结果是原始值，返回结果；
4. 否则，抛出错误。

valueOf(): input 原始类型的值  是否有原始类型的值 有: 返回  没有: 返回对象本身
toString(): input 字符串转换  对象: [object type] type: 对象类型

**相关面试题**

```js
console.log([] + []); // '' 空字符串  调用 toPrimitive(input,type)
console.log([].valueOf()); // []
console.log([].toString()); // '' + '' = ''

console.log([] + {}); // [object Object]
console.log([]); // []
console.log({}.valueOf()); // {}
console.log({}.toString()); // [object Object]

console.log({} + []); // [object Object] 或 0
console.log({} + []); // {} 可能会被识别成代码块
console.log(+[]); // 0
console.log(+''); // 0
```

### 深入理解栈和队列

什么是栈和队列
栈是一种后进后出的数据结构，也就是说 最新添加的项最早被移出, LIFO(Last-In-First-Out, 后进先出)
队列数据结构的访问规则是FIFO(First-In-First-Out, 先进先出)。队列在列表的末端加项, 从列表的前端移出项
堆和栈: 都是存储数据的

数据结构 js
push、pop、unshift、shift方法

```js
// 数组 栈 队列
var arr = [1, 2, 3, 4, 5, 6];
// push pop 尾部出入栈
arr.push(7);
console.log(arr); // [1, 2, 3, 4, 5, 6, 7]
var val = arr.pop();
console.log(arr); // [1, 2, 3, 4, 5, 6]
console.log(val); // 7

// unshift shift 开头出入栈
arr.unshift(7);
console.log(arr); // [7, 1, 2, 3, 4, 5, 6]
var val = arr.shift();
console.log(arr); // [1, 2, 3, 4, 5, 6]
console.log(val); // 7
```

尾部出入栈 不影响原有数据的位置索引  --效率高
开头出入栈   影响原有数据的位置索引  --效率低

### 你不知道的sort排序

sort是如何排序的
如何解决sort排序的问题

```js
var arr = [1, 3, 4, 2, 6, 5];
console.log(arr.sort()); // [1, 2, 3, 4, 5, 6]
var arr = [3, '沫沫', 'a', 25, 15, 18, 9, 22];
console.log(arr.sort()); // [15, 18, 22, 25, 3, 9]
console.log(arr.sort()); // [15, 18, 22, 25, 3, 9, 'a', '沫沫']
```

sort: 1.默认升序
      2.将排序的元素转为字符串 `['3','25',...]` 找对象字符串的Unicode码表
   解决方法
  1.定义一个比较器函数
   sort(callback)
   function(x,y){return x-y}
      小于0 x移到y前面
      大于0 x移到y后面
      等于0 不交换

```js
var arr = [3, 25, 15, 18, 9, 22];
arr.sort(function (x, y) {
  return x - y; //升序
  // return y - x; // 降序
});
console.log(arr.reverse()); // [25, 22, 18, 15, 9, 3]
// 利用 reverse 反转 将 升序转换为降序排序
```

### Date对象中getMonth()需要注意哪些点

存储或者获取月份时需要注意是0-11
```js
var now = new Date();
console.log(now.getTime()); // 1635246384407 1970 1 1 0 至今的一个毫秒数
console.log(now.getDay()); // 本周的第几天 1~7
console.log(now.getDate()); // 本月的第几号
console.log(now.getMonth() + 1); // 月份 0~11
```

js 设计时参照java1.1 now.getMonth():0-11=>1-12

获取时间 now: 本地客户端

### 开发中编码和解码使用场景有哪些

js对文字进行编码涉及3个函数：escape,encodeURI,encodeURIComponent，
          相应3个解码函数：unescape,decodeURI,decodeURIComponent

传递参数时需要使用encodeURIComponent，这样组合的url才不会被#等特殊字符截断。
进行url跳转时可以整体使用encodeURI
js使用数据时可以使用escape
   escape对0-255以外的unicode值进行编码时输出%u****格式，其它情况下escape，encodeURI，encodeURIComponent编码结果相同。
   最多使用的应为encodeURIComponent，它是将中文、韩文等特殊字符转换成utf-8格式的url编码，所以如果给后台传递参数需要使用encodeURIComponent时需要后台解码对utf-8支持（form中的编码方式和当前页面编码方式相同）
   escape不编码字符有69个：*，+，-，.，/，@，_，0-9，a-z，A-Z
   encodeURI不编码字符有82个：!，#，$，&，'，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z
   encodeURIComponent不编码字符有71个：!， '，(，)，*，-，.，_，~，0-9，a-z，A-Z

unescape 方法  从用 escape 方法编码的 String 对象中返回已解码的字符串。
decodeURI 方法  返回一个已编码的统一资源标识符 (URI) 的非编码形式。
decodeURIComponent 方法  返回统一资源标识符 (URI) 的一个已编码组件的非编码形式。
   URIComponent 是一个完整的 URI 的一部分

```js
var url = 'https://www.ioinn.cn?key=hello&name=张三&num=123';
      //   escape 和 unescape
console.log(escape(url)); // 冒号被转码了 // https%3A//www.ioinn.cn%3Fkey%3Dhello%26name%3D%u5F20%u4E09%26num%3D123
var es = escape(url);
console.log(unescape(es)); // 解码

      //   encodeURI 和 decodeURI
console.log(encodeURI(url)); // https://www.ioinn.cn?key=hello&name=%E5%BC%A0%E4%B8%89&num=123
var ec = encodeURI(url);
console.log(decodeURI(ec)); // https://www.ioinn.cn?key=hello&name=张三&num=123

      //   encodeURIComponent 和 decodeURIComponent
console.log(encodeURIComponent(url)); // https%3A%2F%2Fwww.ioinn.cn%3Fkey%3Dhello%26name%3D%E5%BC%A0%E4%B8%89%26num%3D123
var ecent = encodeURIComponent(url);
console.log(decodeURIComponent(ecent)); // https://www.ioinn.cn?key=hello&name=张三&num=123
```
      

### 深入理解DOM树加载过程

### 三种事件绑定的异同

### 带你深入理解事件触发，事件捕获与事件冒泡

### 常用阻止默认行为的两种方式

### 开发中使用history和location需要注意哪些

### 常见函数的四种类型有哪些

### 一定要知道的变量和函数提升

### 带你深入理解作用域和作用域链

### 带你图解执行环境

### 开发中重载和多态的使用场景有哪些

### 高频面试题闭包理解

### 开发中call、apply、bind的使用场景区分

### new的执行过程有哪几步

### 开发中使用this的坑有哪些

### 面试高频如何理解面向对象

### 图解原型和原型链

### 开发中如何使用继承

### 开发中如何运用 Object.defineProperty() 方法
