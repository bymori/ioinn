---
title: JavaScript中的30个重难点
date: 2021-10-25 22:20:39
permalink: /pages/8335d0/
categories:
  - 前端
  - JavaScript文章
tags:
  - 数据类型
  - 表达式运算符和分支结构
  - 内置对象
  - JS DOM
  - JS BOM
  - 函数对象★
  - 面向对象★
---

主要涵盖了面试中常见的面试题，一些比较难以理解的知识点以及开发中常见的问题
<!-- more -->
## 数据类型

### JS中有哪些数据类型

JavaScript 中的值都具有特定的类型。例如，字符串或数字。

在 JavaScript 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）。

- 原始类型(基本类型)
  - Number BigInt String Boolean（逻辑类型） null 值 undefined 值
- 引用类型(复杂类型)
  - object 类型和 symbol 类型

### typeof 和 instanceof 检测数据类型的异同

typeof返回值是一个字符串，该字符串说明运算数的类型,结果为number, boolean,string,function（函数），object(NULL,数组，对象），undefined

instanceof 是用来判断 A 是否为 B 的实例对象，检测的是原型

<code-group>
  <code-block title="typeof" active>
  ```js
  console.log(typeof 123); // number
  console.log(typeof true); // boolean
  console.log(typeof 'ioinn'); // string
  console.log(typeof undefined); // undefined

  console.log(typeof null); // object
    // 计算机typeof 返回的数据类型 机器码 01011:000 => object
    // null 0000000...000 => object
    // js bug

  console.log(typeof []); // object // 引用类型
  console.log(typeof new Date()); // object

  console.log(typeof {}); // object
  console.log(typeof function () {}); // function
  console.log(typeof Array); // function  // 为什么不是object类型
    // typeof 引用类型 object: object function
    // object 定义一个[[call]]: function object

  var str = 'ioinn';
  console.log('--------');
  console.log(str); // ioinn
  console.log(typeof str); // string
  console.log('--------');
  var str1 = new String('ioinn'); // 实例化后的对象
  console.log(str1); // {}
    // key : value
    // 0: "i"
    // 1: "o"
    // 2: "i"
    // 3: "n"
    // 4: "n"
  console.log(typeof str1); // object

    // typeof 少null 多function

  ```
  </code-block>

  <code-block title="instanceof">
  ```js
  // instanceof检测 boolean: true false
      // A instanceof B  A 是否是由 B 实例化出来的
    console.log([] instanceof Array); // true
    console.log({} instanceof Object); // true
    console.log(new Date() instanceof Date); // true
    function Person() {}
    console.log(new Person() instanceof Person); // true

    console.log([] instanceof Object); // true
    console.log(new Date() instanceof Object); // true
    console.log(new Person() instanceof Object); // true
      //instanceof 原型链 A instanceof B true,B instanceof c true

    if (typeof val !== undefined) {}
    console.log(Object.prototype.toString.call('1')); // [object String]
    console.log(Object.prototype.toString.call([])); // [object Array]
  ```

  </code-block>
</code-group>

### 深入理解数据的存储形式-堆栈

什么是栈:计算机为原始类型开辟的一 块内存空间 string number ...

什么是堆：计算机为引用类型开辟的一块内存空间 object

```js
var a = 'ioinn';
var b = a;
b = 'momo';
console.log(a, b); // ioinn momo

var c = { key: 1 };
var d = c;
d.key = 2;
console.log(c, d); // {key: 2} {key: 2}

// c d ['x00123','x00123'] -> {key: 2 }
// c d 'x00123' -> {key: 2 }  {key: 2 }
```

### 深浅拷贝有哪些方式

深拷贝与浅拷贝，简单来说

就是假如 B 复制了 A, 当修改 A 时, 看 B 是否会发生变化, 如果 B 也跟着变了, 说明这是 浅拷贝

如果 B 没变, 就是 深拷贝

```js
// 遍历
var obj = {
  a: 'hello',
  b: {
    a: 'world',
    b: 111,
  },
  c: [11, 'ioinn', 'momo'],
};
```

<code-group>
  <code-block title="浅拷贝" active>
  ```js
  // 浅拷贝
      objCopy;
      function simpleClone(objNew) {
        var obj = {};
        for (var i in objNew) {
          obj[i] = objNew[i];
        }
        return obj;
      }
      var objCopy = simpleClone(obj);
      //   objCopy.b.a = 'world111';
      console.log(obj);
      console.log(objCopy);

      //   Object.create() 复制到原型上
      var objCopyCreate = Object.create(obj);
      objCopy.b.a = 'world111';
      console.log(obj);
      console.log(objCopyCreate);

  ```
  </code-block>

  <code-block title="深拷贝">
  ```js
  // 深拷贝
      function deepClone(startObj, endObj) {
        var obj = endObj || {};
        for (var i in startObj) {
          if (typeof startObj[i] === 'object') {
            obj[i] = startObj[i].constructor === Array ? [] : {};
            deepClone(startObj[i], obj[i]);
          } else {
            obj[i] = startObj[i];
          }
        }
        return obj;
      }
      var objCopy = deepClone(obj);
      objCopy.b.a = 'world111';
      objCopy.c[0] = '22';
      console.log(obj); // "world" 11
      console.log(objCopy); // "world111" "22"

      // JSON.parse JSON.stringify
      var objCopy = JSON.parse(JSON.stringify(obj)); // object -> string -> object
      objCopy.b.a = 'world111';
      objCopy.c[0] = '22';
      console.log(obj); // "world" 11
      console.log(objCopy); // "world111" "22"
  ```

  </code-block>
</code-group>

### 开发中常见数据类型转换有哪些坑

特殊类型的隐式转换 NaN 0 undefined null '' -> 这五种类型会隐式转换为false  其他均为 true

```js
var val = 0;
if (!val) {
  // val 可能等于 NaN 0 undefined ...
} else {
}
var bool = Boolean(NaN);
console.log(bool); //false
```

逻辑运算符 && 和 || 在隐式转换下的情况

```js
console.log(true && true); // true false
console.log(true || true); // false true
console.log(0 && 5); // 0 true true
console.log(0 || 5); // 5 false true
// if方式 耗能较大
var a = 8;
if (a === 0) {
  console.log(a);
} else {
  console.log(1);
}
```

== 和 === 的区别

```js
console.log(undefined == null); // true 对比值 会进行隐式转换 0 == 0
console.log(undefined === null); //false 对比 值 和 类型 不会进转换
// 尽量使用 === 避免因隐式转换带来的不必要的错误 因为这是不易排查的
if (a !== b) {
  console.log();
}
```

## 表达式运算符和分支结构

### 运算符多的情况下需要注意哪些

[运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table)

```js
  // 优先级 +-*/ && || () -= -- ++
  // (1+2)(val || val2)

  // js舍入误差
console.log(0.1 + 0.2); //0.30000000000000004
// js 采用 IEEE754 二进制浮点数算术标准 进行存储
// 0.1 ->0001100110011001100110011001100110011001100110011001101
// 0.2 -> 0.001100110011001100110011001100110011001100110011001101
//   console.log((0.1).toString(2));
//   console.log((0.2).toString(2));
//   console.log((0.1 + 0.2).toString(2)); /0100110011001100110011001100110011001100110011001101

  // 解决方案1
console.log(parseFloat((0.1 + 0.2).toFixed(2))); // 0.3

  // 解决方案2
function add(num1, num2) {
  m = Math.pow(10, 2);
  return (num1 * m + num2 * m) / m;
}
console.log(add(0.1, 0.2));
```

### 开发中如何优化for循环

```js
  // for(){}
  // 性能优化
for (var i = 0; i < arr.length; i++) {
  // do something
}
for (var i = 0, len = arr.length; i < len; i++) {
  // do something
}

  // 算法
// 1 + 2 + 3 + 4 + ...... + 10000
for (var i = 1; i <= 10000; i++) {
  // sum += i;
}
//   100(100+1)/2 = 5050
//   ((startNum + endNum) * endNum) / 2;

  // leetCode 算法
```

## 内置对象

### js中常见的内置对象有哪些

```js
// 三种包装对象：String、Number、Boolean 构造函数转换为对象
      // 其他常用的标准内置对象：Array、Date、Function、Object...

      var str = 'ioinn';
      var str = new String('hello');
      //   {0:i,1:o,2:i,3:n,4:n}
      //   str.方法()
      {
        // var str = new String('hello');
        // var str1 = str.fangfa();
        // str = null;
        // console.log(str1);
      }
      //   var num = 1;
      //   var bool = true;
```

### 面试常见装箱和拆箱的理解

**装箱: 把基本数据类型转化为对应的引用数据类型的操作**

```js
var num = 123;
var objNum = new Number(123);
console.log(typeof num); // number
console.log(typeof objNum); // object
```

**拆箱: 将引用类型对象转换为对应的值类型对象**

```js
valueOf()
var objNum = new Number(123);
console.log(typeof objNum.valueOf(), objNum.valueOf()); // number 123
```

```js
// js toPrimitive(input,type) input:传入的值  type:值类型
```

input是输入的值，type 是期望转换的类型，他可以是字符串，也可以是数字。
如果转换的类型是number，会执行以下步骤：

1. 如果input是原始值，直接返回这个值；
2. 否则，如果input是对象，调用input.valueOf()，如果结果是原始值，返回结果；
3. 否则，调用input.toString() 如果结果是原始值，返回结果；
4. 否则，抛出错误。

valueOf(): input 原始类型的值  是否有原始类型的值 有: 返回  没有: 返回对象本身
toString(): input 字符串转换  对象: [object type] type: 对象类型

**相关面试题**

```js
console.log([] + []); // '' 空字符串  调用 toPrimitive(input,type)
console.log([].valueOf()); // []
console.log([].toString()); // '' + '' = ''

console.log([] + {}); // [object Object]
console.log([]); // []
console.log({}.valueOf()); // {}
console.log({}.toString()); // [object Object]

console.log({} + []); // [object Object] 或 0
console.log({} + []); // {} 可能会被识别成代码块
console.log(+[]); // 0
console.log(+''); // 0
```

### 深入理解栈和队列

什么是栈和队列
栈是一种后进后出的数据结构，也就是说 最新添加的项最早被移出, LIFO(Last-In-First-Out, 后进先出)
队列数据结构的访问规则是FIFO(First-In-First-Out, 先进先出)。队列在列表的末端加项, 从列表的前端移出项
堆和栈: 都是存储数据的

数据结构 js
push、pop、unshift、shift方法

```js
// 数组 栈 队列
var arr = [1, 2, 3, 4, 5, 6];
// push pop 尾部出入栈
arr.push(7);
console.log(arr); // [1, 2, 3, 4, 5, 6, 7]
var val = arr.pop();
console.log(arr); // [1, 2, 3, 4, 5, 6]
console.log(val); // 7

// unshift shift 开头出入栈
arr.unshift(7);
console.log(arr); // [7, 1, 2, 3, 4, 5, 6]
var val = arr.shift();
console.log(arr); // [1, 2, 3, 4, 5, 6]
console.log(val); // 7
```

尾部出入栈 不影响原有数据的位置索引  --效率高
开头出入栈   影响原有数据的位置索引  --效率低

### 你不知道的sort排序

sort是如何排序的
如何解决sort排序的问题

```js
var arr = [1, 3, 4, 2, 6, 5];
console.log(arr.sort()); // [1, 2, 3, 4, 5, 6]
var arr = [3, '沫沫', 'a', 25, 15, 18, 9, 22];
console.log(arr.sort()); // [15, 18, 22, 25, 3, 9]
console.log(arr.sort()); // [15, 18, 22, 25, 3, 9, 'a', '沫沫']
```

sort: 1.默认升序
      2.将排序的元素转为字符串 `['3','25',...]` 找对象字符串的Unicode码表
   解决方法
  1.定义一个比较器函数
   sort(callback)
   function(x,y){return x-y}
      小于0 x移到y前面
      大于0 x移到y后面
      等于0 不交换

```js
var arr = [3, 25, 15, 18, 9, 22];
arr.sort(function (x, y) {
  return x - y; //升序
  // return y - x; // 降序
});
console.log(arr.reverse()); // [25, 22, 18, 15, 9, 3]
// 利用 reverse 反转 将 升序转换为降序排序
```

### Date对象中getMonth()需要注意哪些点

存储或者获取月份时需要注意是0-11

```js
var now = new Date();
console.log(now.getTime()); // 1635246384407 1970 1 1 0 至今的一个毫秒数
console.log(now.getDay()); // 本周的第几天 1~7
console.log(now.getDate()); // 本月的第几号
console.log(now.getMonth() + 1); // 月份 0~11
```

js 设计时参照java1.1 now.getMonth():0-11=>1-12

获取时间 now: 本地客户端

### 开发中编码和解码使用场景有哪些

js对文字进行编码涉及3个函数：escape,encodeURI,encodeURIComponent，
          相应3个解码函数：unescape,decodeURI,decodeURIComponent

传递参数时需要使用encodeURIComponent，这样组合的url才不会被#等特殊字符截断。
进行url跳转时可以整体使用encodeURI
js使用数据时可以使用escape
   escape对0-255以外的unicode值进行编码时输出%u****格式，其它情况下escape，encodeURI，encodeURIComponent编码结果相同。
   最多使用的应为encodeURIComponent，它是将中文、韩文等特殊字符转换成utf-8格式的url编码，所以如果给后台传递参数需要使用encodeURIComponent时需要后台解码对utf-8支持（form中的编码方式和当前页面编码方式相同）
   escape不编码字符有69个：*，+，-，.，/，@，_，0-9，a-z，A-Z
   encodeURI不编码字符有82个：!，#，$，&，'，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z
   encodeURIComponent不编码字符有71个：!， '，(，)，*，-，.，_，~，0-9，a-z，A-Z

unescape 方法  从用 escape 方法编码的 String 对象中返回已解码的字符串。
decodeURI 方法  返回一个已编码的统一资源标识符 (URI) 的非编码形式。
decodeURIComponent 方法  返回统一资源标识符 (URI) 的一个已编码组件的非编码形式。
   URIComponent 是一个完整的 URI 的一部分

```js
var url = 'https://www.ioinn.cn?key=hello&name=张三&num=123';
      //   escape 和 unescape
console.log(escape(url)); // 冒号被转码了 // https%3A//www.ioinn.cn%3Fkey%3Dhello%26name%3D%u5F20%u4E09%26num%3D123
var es = escape(url);
console.log(unescape(es)); // 解码

      //   encodeURI 和 decodeURI
console.log(encodeURI(url)); // https://www.ioinn.cn?key=hello&name=%E5%BC%A0%E4%B8%89&num=123
var ec = encodeURI(url);
console.log(decodeURI(ec)); // https://www.ioinn.cn?key=hello&name=张三&num=123

      //   encodeURIComponent 和 decodeURIComponent
console.log(encodeURIComponent(url)); // https%3A%2F%2Fwww.ioinn.cn%3Fkey%3Dhello%26name%3D%E5%BC%A0%E4%B8%89%26num%3D123
var ecent = encodeURIComponent(url);
console.log(decodeURIComponent(ecent)); // https://www.ioinn.cn?key=hello&name=张三&num=123
```

## JS DOM

### 深入理解DOM树加载过程

在浏览器中输入url，交给DNS域名解析，找到IP，向服务器发起请求；(里面还有缓存，http协议，TCP...)
服务器返回数据，浏览器接收文件(html,css,js,img...)，二进制文件

- html:二进制转换为html
- 构建DOM树：HTML解析器
  - Token->Node->DOM
  - Token词法解析，根是"document"对象
  - Node:HTMLDivElement
  - DOM:DOM和标签基本是一一对应的关系div
- 解析过程中：
  - 1.遇到link的外部css，遇到css的代码会进行css加载，并行解
  - 2.遇到script标签的时候，会先去执行js的内容，直至脚本完成执行，然后继续构建DOM；
  - 底部引入Javascript代码的原因。或者说可以在头部引用，但是前提是加上async、defer,或window.onload:
    - 解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载
    - 如果script标签设置了该属性，则浏览器会异步下载该文件并且不会影响后续DOM的渲染；
    - 如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script；
    - defer脚本会在文档渲染完毕后，DOMContentLoaded事件调用前执行；脚本会被延迟到整个页面都解析完毕后再运行
- 构建css树：css解析器
  - 每个css文件解析为样式表对象scctyleSheet,每个对象都包含cssRule,cssRule包含选择器和声明对象，以及其他与css语法对应的对象。
  - Token解析:css的词法及语法文法
  - Node->CSSOM
- 构建render树：渲染树=DOM树+css树
  - 布局layout与绘制paint:计算对象之间的大小，距离确定每个节点在屏幕上的确切坐标；映射浏览器屏幕绘制；使用UI后端层绘制每个节点
    - reflow(回流)：当元素属性发生改变且影响布局时(宽度、高度、内外边距等)，产生回流，相当于刷新页面
    - repaint(重绘)：当元素属性发生改变且不影响布局时(背景颜色，透明度，字体样式等)，产生重绘，相当于不刷新页面，动态更新内容。
  - 重绘不一定引起回流，回流必将引起重绘

### 三种事件绑定的异同

```html
<input type="button" value="html事件点击" onclick="fun()" />
<input type="button" value="dom0级事件" id="btn" />
<input type="button" value="dom2级事件" id="btn1" />
```

```js
// 1.html事件
      function fun() {
        alert('hello html');
      }

//dom0级事件（事件绑定）
//通过js代码给元素onclick属性赋值
document.getElementById('btn').onclick = function () {
  alert('DOM0级事件 1');
};
document.getElementById('btn').onclick = function () {
  alert('DOM0级事件 2');
};

//  dem2级事件(事件监听)
// DOM.addEventListener(event,function[,useCapture])  //移除：removeEventListener
//    event: (必须) 事件名，支持所有DOM事件
//    function: (必须) 指定事件触发时执行的函数
//    useCapture: (可选) 指定事件是否在捕获或冒泡阶段执行
//        true 捕获
//        false 冒泡  默认为false
// IE8:DOM.attachEvent(event,function)
//    event: (必须) 事件类型，需加 "on" 例如: onclick
//    function: (必须) 指定事件触发时执行的函数

document.getElementById('btn1').addEventListener('click', fun2);
document.getElementById('btn1').addEventListener('click', fun3);
function fun2() {
  alert('hello DOM2 1');
}
function fun3() {
  alert('hello DOM2 2');
}
```

事件监听的优点：可以绑定多个事件，常规的事件绑定只执行最后绑定的事件
    原因：js不支持事件重载，绑定事件相当于一个变量存储的是函数的地址，如果再绑定一个事件，相当于变量指向另一个函数的地址；事件监听相当于订阅发布者，改变了数据，触发了事件，订阅这个事件的函数被执行。
总结：事件绑定相当于绑定到DOM的属性，重复绑定会覆盖。而事件监听相当于添加属性到DOM对象，多次监听，就会多次添加属性到DOM对象，所以都会触发，不会覆盖。

### 深入理解事件触发，事件捕获与事件冒泡

```js
<div id="demo">
  div0
  <div id="demo1">
    div1
    <div id="demo2">点击div2</div>
  </div>
</div>

<ul id="demo3">
  <li>111</li>
  <li>222</li>
  <li>333</li>
</ul>

// 什么是事件对象: 事件触发时自动创建的，封装了事件发生的元素和属性信息
var obj2 = document.getElementById('demo2');
obj2.addEventListener(
  'click',
  function (e) {
    e.stopPropagation();
    // IE8: window.event arguments[0]
    var e = e || window.event;
    console.log(e);
    // IE8: e.srcElement
    if (e.target.nodeName.toLowerCase() == 'div') {
      alert(e.target.innerHTML);
    }
  },
  false
  // true 捕获  false 冒泡
);

//  事件的一个周期
//  事件捕获，事件对象的触发 冒泡触发
//  事件冒泡应用: 1.阻止冒泡 e.stopPropagation(); IE: e.cancelBubble = true
var obj = document.getElementById('demo');
obj.addEventListener(
  'click',
  function (e) {
    alert('div0');
  },
  false
);
var obj1 = document.getElementById('demo1');
obj1.addEventListener(
  'click',
  function (e) {
    alert('div1');
  },
  false
);

// 事件委托
var obj3 = document.getElementById('demo3');
obj3.addEventListener(
  'click',
  function (e) {
    // IE8: window.event arguments[0]
    var e = e || window.event;
    console.log(e);
    // IE8: e.srcElement
    if (e.target.nodeName.toLowerCase() == 'li') {
      alert(e.target.innerHTML);
    }
  },
  false
);
```

### 常用阻止默认行为的两种方式

```js
<a href="https://ioinn.cn">io小栈</a>
<form action="https://ioinn.cn">
  <input type="submit" value="提交" name="sub" id="submit" />
</form>

// 让链接不跳转 或 按钮不提交
//  常见默认行为：
//    a标签自动跳转
//    input表单自动提交
var a = document.querySelector('a');
var input = document.getElementById('submit');
input.onclick = function (e) {
  e.preventDefault();
  //阻止默认事件
  //preventDefault()[dom标准写法(ie678不兼容)]
  //ie678用 returnValue
  //或者利用return false也能阻止默认行为, 但是后面的代码不再执行, 没有兼容问题(只限传统注册方式)
  // return false;
};
```

## JS BOM

### 开发中使用history和location需要注意哪些

**history**
`window.history` 属性指向History对象，它表示当前浏览器历史 www.ioinn.cn www.taobao.com

- 浏览器历史记录是一个栈数据结构(先进后出)

`History.back()` 后退、`History.forward()`前进、`History.go()` 跳转
`History.pushState()` 向栈里推入数据、History.replaceState()向栈里替换数据

**Location**

> Location 对象 window.location和document.location属性，可以拿到这个对象

`Location.href`:整个URL
`Location.protocol`:当前URL的协议，包括冒号(:)
`Location.host`:主机。如果端口不是协议默认的80和433，则不会包括冒号(:)和端口
`Location.hostname`:主机名，不包括端口。
`Location.port`:端口号。
`Location.pathname`:URL的路径部分，从根路径/开始。
`Location.search`:查询字符串部分，从问号？开始。
`Location.hash`:片段字符串部分，从#开始。
`Location.username`:域名前面的用户名。
`Location.password`:域名前面的密码。
`Location.origin`:URL的协议、主机名和端口。

## 函数对象★

### 常见函数的四种类型有哪些

**匿名函数**  定义没有任何变量引用的函数
匿名函数自调: 如果函数只执行一次

```js
(function (a, b) {
  console.log('a = ' + a);
  console.log('b = ' + b);
})(1, 2);
```

总结：优点就是节约内存空间，调用前和调用后内存中不创建任何函数对象

**回调函数(callback)**  如果一个函数作为'对象'交给其他函数使用

```js
var arr = [15, 7, 66, 33, 26];
arr.sort(function (a, b) {
  return a - b;
});
console.log(arr);
  // 异步回调: AJAX
function getPrice(inputparams, callback) {
  $.ajax({
    url: ctx + '/xxx',
    type: 'post',
    data: { field: inputparams },
    async: true,
    success: function (data) {
      result = data;
      callback(result);
    },
  });
}
```

**递归函数**  循环调用函数本身

```js
var f = function (x) {
  if (x === 2) {
    return x;
  } else {
    return x * f(x - 1);
  }
};
console.log(f(5));

  // arguments.callee  注意: 在严格模式(use strict)下不支持使用
function ff(x) {
  if (x === 1) {
    return 1;
  } else {
    return x * arguments.callee(x - 1);
  }
}
console.log(ff(6));
```

**构造函数** 构造函数习惯上首字母大写
调用方式不一样  作用也不一样(构造函数用来创建实例对象)
`Person()` 这个构造函数 `Person`既是函数名 也是这个对象的类名

```js
function Person() {}
new Person(); // 构造函数

function Person() {} // 一般是封装的方法
```

### 一定要知道的变量和函数提升

**js声明提升或者声明提前**
> html css dom树

- js解释引擎:词法分析->语法分析->语法树
- 词法分析是将字符流(char stream ) 转换为记号流(token stream)
- 语法分析成AST(语法树)
- js解析：预编译期(预处理、预解析、预编译)与执行期
- 预编译预解析，当Javascript引擎解析脚本时，它会在预编译期对所有声明的变量和函数进行处理；并且是先预声明变量，再预定义函数

**变量和函数提升**

- 先提升变量，再提升函数
- 变量声明提前，函数声明提前：变量声明提前，值停留在本地；
- 函数是整个代码体提前：
- 注意如果是var fn声明的只是变量提前；函数体停留在本地

```js
console.log(a); // undefined
var a = 10;
function fn() {}
function test() {
  a = 100;
  console.log(a); // 100
  //  坑 这里是声明，会提前，会提前到当前作用域最前面，也就是这个函数的开始处成为一个函数内的局部变量
  var a;
  console.log(a); // 100
  console.log(fn); // ƒ fn() {}
}
test();
console.log(a); // 10  函数内的局部变量已被释放，而且作用域到不了外面
```

### 深入理解作用域和作用域链

作用域scope:一个变量的可用范围 {a:1}-{b:2}-{}... window
作用域链scope chain: 以当前作用域的scope属性为起点依次引用每个AO(Activation Object)对象，又叫执行期上下文,直到window结束，形成多级引用关系chain:
js作用域：ES5
两大类：全局作用域 js window  var a=1 全局 window.a
函数作用域 function(){} function(){}

- 作用域 只能向外访问

解释执行，在执行过程中，JavaScript 引擎是严格按着作用域机制(scope)来执行的，并且JavaScript的变量和函数作用域是在定义时决定的，而不是执行时决定的。JavaScript中的变量作用域在函数体内有效，无块作用域

```js
// 作用域
function a() {
  function b() {
    var bb = 234;
  }
  var aa = 123;
  b();
}
var glob = 100;
a();
console.log(b); //b is not defined
console.log(a); // a(){...}
// arr.push();
// [[scope]] 中所存储执行期上下文对象的集合，这个集合呈链式连接，我们把这种链式连接叫作用域链
// 作用域链： [0,1] => [函数本身作用域,全局的]
```
      
```js
var buttons = [{ name: 'b1' }, { name: 'b2' }, { name: 'b3' }];
function bind() {
  for (var i = 0; i < buttons.length; i++) {
    // i=3
    buttons[i].fun = function () {
      // alert(i);
      console.log(i);
    };
  }
}
bind();
buttons[0].fun(); // 3
buttons[1].fun(); // 3
buttons[2].fun(); // 3
```

### 图解执行环境

浏览器环境栈：js是一个单线程执行
执行环境（执行上下文）：`EC execution context`

- 全局执行环境
- 局部执行环境
变量对象：`VO Variable object` 一般是全局环境下保存变量的对象 {a:1,b:2...}

活动对象：`AO Activation object` 函数的执行环境是在调用时创建的，该对象将代替VO对象来保存当前函数环境中的变量，参数，函数，所以在函数执行环境中VO就是AO function(){a=1,b=[]}

```js
var buttons = [{ name: 'b1' }, { name: 'b2' }, { name: 'b3' }];
function bind() {
  for (var i = 0; i < buttons.length; i++) {
    // i=3
    buttons[i].fun = function () {
      // alert(i);
      console.log(i);
    };
  }
}
bind();
buttons[0].fun(); // 3
buttons[1].fun(); // 3
buttons[2].fun(); // 3
```

![image](https://cdn.jsdelivr.net/gh/bymori/image-PicX@main/blog/image.3kfscb3bki00.png)

### 开发中重载和多态的使用场景有哪些

**重载的概念：**

- 在程序中可以定义相同名字，不同参数的形式的不同函数。
- 函数在调用的函数的时候，自动识别不同参数对应的函数，实现了相同函数名不同的函数调用
- Javascript本身是没有重载的，但是可以通过arguments实现函数重载

**多态**: 同一个东西在不同情况下的表现不同状态：重写和重载

```js
// function 正方形和长方形面积 x*x x*y
// function(x) function(x,y)

function React() {
  // 传入的参数，会以 `argument[x,y,z,...]` 类数组的形式进行体现，每个函数function都有默认的argument

  // 如果传入的是一个参数 那就返回正方形
  if (arguments.length >= 1) {
    this.width = arguments[0];
    this.height = arguments[0];
  }

  // 如果传入的是两个参数 那就返回长方形
  if (arguments.length > 1) {
    this.width = arguments[0];
    this.height = arguments[1];
  }

  // 覆盖原型上的 toString()
  this.toString = function () {
    return `width:${this.width} height:${this.height}`;
  };
}

var r1 = new React(10);
console.log(r1.toString());

var r2 = new React(7, 30);
console.log(r2.toString());
```

### 闭包的理解

**闭包(Closure):作用域**

- 是引用了自由变量的函数这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外
- 所以，有另一种说法认为闭包是由函数和其相关的引用环境组合而成实现信息的驻留（信息的保持，引用在，空间不销毁）

```js
//简单的闭包
var Person = function () {
  var count = 0; // 私有变量
  return function getCount() {
    console.log(count++); // ++ 前加取新值1，后加取旧值0
  };
};

var p = Person();
p(); // 0
p(); // 1
p(); // 2
// 作用域 EC
// [[GEC,VO:{p:new Person,Person}],[EC,AO:{count3,}]]

// 闭包的应用
var buttons = [{ name: 'b1' }, { name: 'b2' }, { name: 'b3' }];
function bind() {
  for (var i = 0; i < buttons.length; i++) {
    (function (num) {
      // 相当于 var num = i
      buttons[i].fun = function () {
        console.log(num);
      };
    })(i);
  }
}
bind();
buttons[0].fun(); // 1
buttons[1].fun(); // 2
buttons[2].fun(); // 3

// 解决方法
(function (num) {
  // 相当于 var num = i
  buttons[i].fun = function () {
    console.log(num);
  };
})(i); // 这个是把 i 当作局部变量传入给 num , 保存了当前这个局部变量 形成闭包
```

::: warning
闭包的缺点：闭包导致内存会驻留，如果是大量对象的闭包环境注意内存消耗
:::

### 开发中call、apply、bind的使用场景区分

Function对象**call**、**apply**、**bind**

- apply（）方法调用一个函数，其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。
- apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性。

- Function.apply(obj,args)方法能接收两个参数
- Function.call(obj,args) 只是参数形式的不同
- obj: 这个对象将代替Function类里this对象
- args: 这个是数组，它将作为参数传给 Function(args -> arguments)

```js
// call apply的区别
// call: 单个的参数传入
// apply: 以数组的形式传入
var stu1 = {
  name: '沫沫',
  age: 18,
  say: function (school, grade) {
    console.log(`${this.name}今年${school}年级${grade}`);
  },
};
var stu2 = {
  name: '末日',
};
stu1.say.call(stu2, '青', '三'); // 末日今年青年级三
stu1.say.apply(stu2, ['北', '二']); // 末日今年北年级二

// 应用: 类数组转数组 slice function
//   var arr = Array.prototype.slice.apply(arguments);

// bind: 类似于call 但是与其不同的是 call 调用后可以立即执行，但是bind需要一个变量进行接收后再执行
//   var val = stu1.say.bind();
```

### new的执行过程有哪几步

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}
var p = new Person('沫沫', 18); // 实例化对象
console.log(p.name); // 沫沫

//new 的执行过程

//1 创建一个新对象
var obj = new Object(); // {}

//2 把obj的proto指向构造函数的prototype对象 实现继承
obj.__proto__ = Fn.prototype;

//3 将新创建的对象obj作为this的上下文
var result = Fn.call(obj);

//4 返回创建的对象obj（如果该函数没有返回对象，则返回this）
if (typeof result === 'object') {
  return result; // func = result
} else {
  return obj; // func = obj
}
```

### 开发中使用this的坑有哪些

**this用法**

- 指代当前调用的这个对象：4种绑定，规则分别是：默认绑定、隐式绑定、显示绑定、new绑定。优先级从低到高

```js{}
var man = {
  name: '沫沫',
  age: 19,
  getName: function () {
    console.log(this.name);
  },
  getAge: function () {
    //   function a() {
    //     // 局部函数
    //     console.log(this + ' 1 ' + this.age); // [object Window] 1 undefined
    //     // 局部函数的this指向 window
    //   }
    var self = this;
    function a() {
      // 局部函数
      console.log(self + ' 1 ' + self.age); // [object Object] 1 19
      // 通过 self 保留了 this 指向
    }
    a(); // window.a()
    console.log(this + ' 2 ' + this.age); // [object Object] 2 19
  },
};
man.getName(); // 沫沫
man.getAge();
```

```js
// 误区
//   $('#btn').click(function () {
//     // this 是被点击的 #content
//     var self = this;
//     $('.content').each(function () {
//       // $('#btn')
//       // this 是 .content 循环中当前的对象
//       // this 让然是刚才被点击的 #content
//     });
//   });
```

```js
// 改变this指向
// call apply bind
var name = '末日';
var obj = {
  name: '沫沫',
  getName: function () {
    console.log(this.name);
  },
};
obj.getName(); // 沫沫
var fn = obj.getName;
fn(); // 末日 window

var fn1 = obj.getName.bind(obj); // 把this的指向绑定给obj
fn1(); // 沫沫
```

```js{2-6}
// bind方法
Function.prototype.newBind = function (obj) {
  var self = this;
  return function () {
    self.apply(obj);
  };
};
var bname = 'Tom';
var o = {
  bname: 'Jack',
  get: function () {
    console.log(this.bname);
  },
};

var f = o.get.newBind(o);
f(); // Jack
```

## 面向对象★

### 面试高频如何理解面向对象

### 图解原型和原型链

### 开发中如何使用继承

### 开发中如何运用 Object.defineProperty() 方法

## 总结
