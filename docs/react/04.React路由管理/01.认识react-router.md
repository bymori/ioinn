---
title: 认识react-router
date: 2021-12-16 20:39:25
permalink: /pages/1ca369/
categories:
  - react
  - React路由管理
tags:
  - 
---
## 路由的由来

**路由（routing）**是一个网络工程里面的术语, 就是通过互联的**网络**把**信息**从源地址传输到目的地址的活动。

路由中有一个非常重要的概念叫路由表

- 路由表本质上就是一个映射表, 决定了数据包的指向
<!-- more -->

路由的概念出现最早是在后端路由中实现的，原因是web的发展主要经历了这样一些阶段：

- 后端路由阶段
- 前后端分离阶段
- 单页面富应用（SPA）

### 阶段一：后端路由阶段

早期的网站开发整个HTML页面是由服务器来渲染的

服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示

**但是, 一个网站, 这么多页面服务器如何处理呢?**

- 一个页面有自己对应的网址, 也就是URL
- URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个`Controller`进行处理
- `Controller`进行各种处理, 最终生成HTML或者数据, 返回给前端
- 这就完成了一个IO操作

上面的这种操作, 就是**后端路由**

- 当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户顿
- 这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也**有利于SEO的优化**

**后端路由的缺点**:

- 一种情况是整个页面的模块由后端人员来编写和维护的
- 另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码
- 而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情

### 阶段二：前后端分离阶段

**前端渲染的理解**：

- 每次请求涉及到的静态资源都会从静态资源服务器获取
- 这些资源包括HTML+CSS+JS，然后在前端对这些请求回来的资源进行渲染
- 需要注意的是，客户端的每一次请求，都会从静态资源服务器请求文件
- 同时可以看到，和之前的后断路由不同，这时后端只是负责提供API了

**前后端分离阶段**：

- 随着Ajax的出现, 有了前后端分离的开发模式；
- 后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中；
- 这样做最大的优点就是前后端责任的清晰，后端专注于数据上，前端专注于交互和可视化上；
- 并且当移动端(iOS/Android)出现后，后端不需要进行任何处理，依然使用之前的一套API即可；
- 目前很多的网站依然采用这种模式开发(jQuery开发模式)

### 阶段三：单页面富应用（SPA）

**单页面富应用的理解**：

- 单页面富应用的英文是`single-page application`，简称SPA；
- 整个Web应用只有实际上只有一个页面，当URL发生改变时，并不会从服务器请求新的静态资源；
- 而是通过JavaScript监听URL的改变，并且根据URL的不同去渲染新的页面；

**如何可以应用URL和渲染的页面呢？前端路由**

- 前端路由维护着URL和渲染页面的映射关系；
- 路由可以根据不同的URL，最终让我们的框架（比如Vue、React、Angular）去渲染不同的组件；
- 最终我们在页面上看到的实际就是渲染的一个个组件页面

## 前端路由的原理

前端路由是如何做到URL和内容进行映射呢？
**监听URL的改变**

URL发生变化，同时不引起页面的刷新有两个办法：

- 通过URL的hash改变URL
- 通过HTML5中的history模式修改URL

当监听到URL发生变化时，我们可以通过自己判断当前的URL，决定到底渲染什么样的内容。

### URL的hash

URL的hash也就是`锚点(#)`, 本质上是改变`window.location的href属性`

我们可以通过直接赋值`location.hash`来改变href, 但是**页面不发生刷新**

```js
// 获取router-view的DOM
const routerViewEl = document.getElementsByClassName('router-view')[0];

// 监听URL的改变
window.addEventListener('hashchange', () => {
  switch (location.hash) {
    case '#/home':
      routerViewEl.innerHTML = '首页';
      break;
    case '#/about':
      routerViewEl.innerHTML = '关于';
      break;
    default:
      routerViewEl.innerHTML = '';
  }
});
```

注意：

- hash的优势就是兼容性更好，在老版IE中都可以运行
- 但是缺陷是有一个#，显得不像一个真实的路径

![hash](https://cdn.jsdelivr.net/gh/bymori/image-PicX@main/img/iamlxeh0pr-1639659243348.png)

## HTML5的history

history接口是**HTML5新增**的, 它有六种模式改变URL而不刷新页面

- **replaceState**：替换原来的路径
- **pushState**：使用新的路径
- **popState**：路径的回退
- **go**：向前或向后改变路径
- **forward**：向前改变路径
- **back**：向后改变路径

```js
// 1.获取router-view的DOM
const routerViewEl = document.getElementsByClassName('router-view')[0];

// 获取所有的a元素, 自己来监听a元素的改变
const aEls = document.getElementsByTagName('a');
for (let el of aEls) {
  el.addEventListener('click', (e) => {
    e.preventDefault(); // 阻止a元素默认事件
    const href = el.getAttribute('href');
    history.pushState({}, '', href);
    urlChange();
  });
}

// 执行返回操作时, 依然来到urlChange
window.addEventListener('popstate', urlChange);

// 监听URL的改变
function urlChange() {
  switch (location.pathname) {
    case '/home':
      routerViewEl.innerHTML = '首页';
      break;
    case '/about':
      routerViewEl.innerHTML = '关于';
      break;
    default:
      routerViewEl.innerHTML = '';
  }
}
```
