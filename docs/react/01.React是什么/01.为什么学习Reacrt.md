---
title: 为什么学习Reacrt
date: 2021-12-13 09:28:54
permalink: /pages/a41858/
categories:
  - react
  - React是什么
tags:
  - 
---

## React是什么?

![React](https://cdn.jsdelivr.net/gh/bymori/image-PicX@main/img/tmw4jrk4bz-1639359834510.png)

主要的任务就是构建用于界面，而构建用于界面离不开三个技术:

- **HTML**：构建页面的结构
- **CSS**：构建页面的样式
- **JavaScript**：页面动态内容和交互

使用最原生的HTML、CSS、JavaScript可以构建完整的用户界面，**但是**会存在很多问题

- 比如操作DOM兼容性的问题
- 比如过多兼容性代码的冗余问题
- 比如代码组织和规范的问题

### 常见的JavaScript库

现在前端领域最为流行的几大框架：

- [Vue](https://github.com/vuejs/vue)
- [React](https://github.com/facebook/react)
- [Angula](https://github.com/angular/angular)
- [solid](https://github.com/solidjs/solid)
- [Svelte](https://github.com/sveltejs/svelte)

### React的特点

1. 声明式设计 −React采用声明范式，可以轻松描述应用
2. 高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互
3. 灵活 −React可以与已知的库或框架很好地配合
4. JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它
5. 组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中
6. 单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单

#### 声明式编程

- 声明式编程是目前整个大前端开发的模式：Vue、React、Flutter、SwiftUI；
- 它允许我们只需要维护自己的状态，当状态改变时，React可以根据最新的状态去渲染我们的UI界面

- 命令式编程: 每做一个操作,都是给计算机(浏览器)一步步命令
- 声明式编程: 虚拟DOM帮助我们从命令式编程转到了声明式编程的模式

![声明式编程](https://cdn.jsdelivr.net/gh/bymori/image-PicX@main/img/em9g7nn0e2-1639360915952.png)

#### 组件化开发

构建管理自身状态的封装组件，然后对其组合以构成复杂的 UI。

![组件化开发](https://cdn.jsdelivr.net/gh/bymori/image-PicX@main/img/0jv461ks9i-1639360989464.png)

## React开发依赖

开发React必须依赖三个库：

- react：包含react所必须的核心代码
- react-dom：react渲染在不同平台所需要的核心代码
- babel：将jsx转换成React代码的工具

对于Vue来说，只是依赖一个vue.js文件即可，但是react要依赖三个库。

- 但是，这三个库是各司其职的，目的就是让每一个库只单纯做自己的事情：
- 在React的`0.14`版本之前是没有react-dom这个概念的，所有功能都包含在react里。
- 为什么要进行拆分呢？原因就是`react-native`
- react包中包含了react和react-native所共同拥有的核心代码。
  - react-dom针对web和native所完成的事情不同：
  - web端：`react-dom`会将jsx最终渲染成真实的DOM，显示在浏览器中
  - native端：`react-dom`会将jsx最终渲染成原生的控件（比如Android中的Button，iOS中的UIButton）

### 引入React依赖

在编写React代码时，这三个依赖都是必不可少的。

- 那么，如何添加这三个依赖：
- 方式一：直接CDN引入
- 方式二：下载后，添加本地依赖
- 方式三：通过npm管理（后续脚手架再使用）

这里直接通过CDN引入，来演练下面的示例程序：

- crossorigin属性，这个属性的目的是为了拿到跨域脚本的错误信息

```js
<script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin ></script>
<script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin ></script>
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
```

在界面上通过React显示一个**Hello World**

注意事项: 使用jsx, 并且希望script中的jsx的代码被解析, 必须在script标签中添加一个 `text/babel` 属性

```js
<script type="text/babel">
  // <h2></h2>: jsx代码
  let message = 'Hello World';
  ReactDOM.render(<h2>{message}</h2>, document.getElementById('app'));
</script>
```

**ReactDOM.render**函数：

- 参数一：传递要渲染的内容，这个内容可以是HTML元素，也可以是React的组件
  - 这里我们传入了一个h2元素，后面我们就会使用React组件
- 参数二：将渲染的内容，挂载到哪一个HTML元素上
  - 这里我们已经提定义一个id为app的div
  - 我们可以通过`{}语法`来引入外部的变量或者表达式

## Hello React案例

- 在界面显示一个文本：Hello World
- 点击下方的一个按钮，点击后文本改变为Hello React

![Hello World](https://cdn.jsdelivr.net/gh/bymori/image-PicX@main/img/4pa22k0crg-1639361156820.png)

```html
<h2 class="title"></h2>
<button class="btn">改变文本</button>

<script>
  // 命令式编程: 每做一个操作,都是给计算机(浏览器)一步步命令
  // 声明式编程: 虚拟DOM帮助我们从命令式编程转到了声明式编程的模式
  // 1.定义数据
  let message = 'Hello World';

  // 2.将数据显示在h2元素中
  const titleEl = document.getElementsByClassName('title')[0];
  titleEl.innerHTML = message;

  // 3.点击按钮,界面的数据发生改变
  const btnEl = document.getElementsByClassName('btn')[0];
  btnEl.addEventListener('click', (e) => {
    message = 'Hello React';
    titleEl.innerHTML = message;
  });
</script>
```

### Hello React – 组件化开发

- 整个逻辑其实可以看做一个整体，那么就可以将其封装成一个组件
  - 我们说过 ReactDOM.render 第一参数是一个HTML原生或者一个组件；
  - 所以我们可以先将之前的业务逻辑封装到一个组件中，然后传入到 `ReactDOM.render` 函数中的第一个参数

- 在React中，如何封装一个组件呢？
  - 这里使用类的方式封装组件：
  - 1.定义一个类（`类名大写`，组件的名称是必须大写的，小写会被认为是HTML元素），继承自`React.Component`
  - 2.实现当前组件的render函数
  - `render`当中返回的jsx内容，就是之后React会帮助我们渲染的内容

```js
class App extends React.Component {
  render() {
    return (<h2>Hello World</h2>);
  }
}
ReactDOM.render(<App />, document.getElementById('app'));
```

### 组件化 - 数据依赖

组件化问题一：**数据在哪里定义**

- 在组件中的数据，我们可以分成两类：
  - 参与界面更新的数据：当数据变量时，需要更新组件渲染的内容
  - 不参与界面更新的数据：当数据变量时，不需要更新将组建渲染的内容
- 参与界面更新的数据我们也可以称之为是参与数据流，这个数据是定义在当前对象的state中
  - 我们可以通过在构造函数中 this.state = {定义的数据}
  - 当我们的数据发生变化时，我们可以调用 this.setState 来更新数据，并且通知React进行update操作
    - 在进行update操作时，就会重新调用render函数，并且使用最新的数据，来渲染界面

```js
class App extends React.Component {
  constructor() {
    super();
    this.state = {
      message: 'Hello World',
    };
  }
}
```

### 组件化 – 事件绑定

组件化问题二：**事件绑定中的this**

- 在类中直接定义一个函数，并且将这个函数绑定到html原生的onClick事件上，当前这个函数的this指向的是谁呢？
- 默认情况下是undefined
  - 很奇怪，居然是undefined；
  - 因为在正常的DOM操作中，监听点击，监听函数中的this其实是节点对象（比如说是button对象）；
  - 这次因为React并不是直接渲染成真实的DOM，我们所编写的button只是一个语法糖，它的本质React的Element对象；
  - 那么在这里发生监听的时候，react给我们的函数绑定的this，默认情况下就是一个undefined；
- 我们在绑定的函数中，可能想要使用当前对象，比如执行 this.setState 函数，就必须拿到当前对象的this
- 我们就需要在传入函数时，给这个函数直接绑定this
- 类似于下面的写法：

```js
<div>
  <h2>{this.state.message}</h2>
  <button onClick={this.btnClick.bind(this)}>改变文本</button>
</div>

btnClick() {
  console.log(this);
}
```

## demo案例

### 电影列表展示

![电影列表展示](https://cdn.jsdelivr.net/gh/bymori/image-PicX@main/img/x1p1i2ub95-1639362910877.png)

```html
  <body>
    <div id="app"></div>

    <!-- 1.引入依赖 -->
    <script src="../react/react.development.js"></script>
    <script src="../react/react-dom.development.js"></script>
    <script src="../react/babel.min.js"></script>

    <!-- 2.编写React代码 -->
    <script type="text/babel">
      class App extends React.Component {
        constructor() {
          super();
          this.state = {
            message: 'Hello World',
            movies: ['肖申克的救赎', '霸王别姬', '阿甘正传', '千与千寻'],
          };
        }

        render() {
          const liArray = [];
          for (let movie of this.state.movies) {
            liArray.push(<li>{movie}</li>);
          }

          return (
            <div>
              <h2>电影列表1</h2>
              <ul>{liArray}</ul>

              <h2>电影列表2</h2>
              <ul>
                {this.state.movies.map((item) => {
                  return <li>{item}</li>;
                })}
              </ul>
            </div>
          );
        }
      }

      ReactDOM.render(<App />, document.getElementById('app'));
    </script>
  </body>
```

### 计数器案例

![计数器案例](https://cdn.jsdelivr.net/gh/bymori/image-PicX@main/img/df52zbkiro-1639363008745.png)

```html
  <body>
    <div id="app"></div>

    <script src="../react/react.development.js"></script>
    <script src="../react/react-dom.development.js"></script>
    <script src="../react/babel.min.js"></script>

    <script type="text/babel">
      class App extends React.Component {
        constructor(props) {
          super(props);

          this.state = {
            counter: 0,
          };
        }

        render() {
          return (
            <div>
              <h2>当前计数:{this.state.counter}</h2>
              {/* <button onClick={this.increment}> +1 </button> */}
              <button onClick={this.increment.bind(this)}> +1 </button>
              <button onClick={this.decrement.bind(this)}> -1 </button>
            </div>
          );
        }

        increment() {
          this.setState({
            counter: this.state.counter + 1,
          });
        }

        decrement() {
          this.setState({
            counter: this.state.counter - 1,
          });
        }
      }

      ReactDOM.render(<App />, document.getElementById('app'));
    </script>
  </body>
```
