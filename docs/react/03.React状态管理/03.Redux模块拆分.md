---
title: Redux模块拆分
date: 2021-12-15 22:59:12
permalink: /pages/f5c94f/
categories:
  - react
  - React状态管理
tags:
  - 
---
## Redux结构划分

如果我们将所有的逻辑代码写到一起，那么当redux变得复杂时代码就**难以维护**

接下来，对代码进行拆分，将`store`、`reducer`、`action`、`constants`拆分成一个个文件
<!-- more -->
- 创建`store/index.js`文件
- 创建`store/reducer.js`文件
- 创建`store/actionCreators.js`文件
- 创建`store/constants.js`文件

**注意**：node中对ES6模块化的支持

从node v13.2.0开始，node才对ES6模块化提供了支持：

- node v13.2.0之前，需要进行如下操作
  - 在package.json中添加属性： `"type": "module"`
  - 在执行命令中添加如下选项：`node --experimental-modules src/index.js`
- node v13.2.0之后，只需要进行如下操作
  - 在package.json中添加属性： `"type": "module"`
  - 注意：导入文件时，需要跟上`.js`后缀名

```json
{
  ...
  "type": "module",
  "scripts": {
    "start": "node index.js",
    "start2": "node --experimental-modules index.js"
  }
}
```

## Redux使用流程

### Redux官方 数据流程图

![ReduxDataFlowDiagram](https://cdn.jsdelivr.net/gh/bymori/image-PicX/typora/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif)

图源来自：[https://redux.js.org/tutorials/fundamentals/part-1-overview#data-flow](https://redux.js.org/tutorials/fundamentals/part-1-overview#data-flow)

## redux融入react代码

目前redux在react中使用是最多的，所以需要将之前编写的redux代码，融入到react当中去。

- Home组件：其中会展示当前的counter值，并且有一个+1和+5的按钮；
- Profile组件：其中会展示当前的counter值，并且有一个-1和-5的按钮；

- 核心代码主要是两个：
  - 在 `componentDidMount` 中定义数据的变化，当数据发生变化时重新设置 `counter`
  - 在发生点击事件时，`调用store`的`dispatch`来派发对应的`action`

### 自定义connect函数

```js
import React from 'react';

const StoreContext = React.createContext();

export { StoreContext };
```

```js
connect
import React, { PureComponent } from 'react';

import { StoreContext } from './context';

export function connect(mapStateToProps, mapDispatchToProps) {
  return function enhanceHOC(WrappedComponent) {
    class EnhanceComponent extends PureComponent {
      constructor(props, context) {
        super(props, context);

        this.state = {
          storeState: mapStateToProps(context.getState()),
        };
      }

      componentDidMount() {
        this.unsubscribe = this.context.subscribe(() => {
          this.setState({
            storeState: mapStateToProps(this.context.getState()),
          });
        });
      }
      componentWillUnmount() {
        this.unsubscribe();
      }

      render() {
        return (
          <WrappedComponent
            {...this.props}
            {...mapStateToProps(this.context.getState())}
            {...mapDispatchToProps(this.context.dispatch)}
          />
        );
      }
    }
    EnhanceComponent.contextType = StoreContext;

    return EnhanceComponent;
  };
}

// about
const mapStateToProps = (state) => {
  return {
    counter: state.counter,
  };
};
const mapDispatchToProps = (dispatch) => {
  return {
    decrement: function () {
      dispatch(decAction());
    },
    subNumber: function (num) {
      dispatch(subAction(num));
    },
  };
};

export default connect(mapStateToProps, mapDispatchToProps)(About);
```

### context处理store

- 上面的connect函数有一个很大的缺陷：依赖导入的store
- 如果我们将其封装成一个独立的库，需要依赖用于创建的store，我们应该如何去获取呢？
  - 正确的做法是我们提供一个Provider，Provider来自于我们创建的Context，让用户将store传入到value中即可

```js
ReactDOM.render(
   <StoreContext.Provider value={store}>
    <App />
  </StoreContext.Provider>,
  document.getElementById('root')
);
```
