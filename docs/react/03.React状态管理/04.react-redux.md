---
title: react-redux
date: 2021-12-16 15:03:07
permalink: /pages/1cec8d/
categories:
  - react
  - React状态管理
tags:
  - 
---
## react-redux使用

redux和react没有直接的关系，你完全可以在React, Angular, Ember, jQuery, or vanilla JavaScript中使用Redux。

尽管这样说，redux依然是和React或者Deku的库结合的更好，因为他们是通过state函数来描述界面的状态，Redux可以发射状态的更新，让他们作出相应
<!-- more -->

虽然我们之前已经实现了connect、Provider这些帮助我们完成连接redux、react的辅助工具，但是实际上redux官方帮助我们提供了 react-redux 的库，可以直接在项目中使用，并且实现的逻辑会更加的严谨和高效。

**安装**react-redux：

```shell
yarn add react-redux
```

```js
// about.js
import React from 'react';

// import { connect } from '../utils/connect';
import { connect } from 'react-redux';

import { decAction, subAction } from '../store/actionCreators';

// ...

export default connect(mapStateToProps, mapDispatchToProps)(About);

// index.js
import { Provider } from 'react-redux';
import store from './store';

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);
```

## 组件中异步操作

在上面简单的案例中，redux中保存的counter是一个本地定义的数据

我们可以直接通过同步的操作来dispatch action，state就会被立即更新。

但是真实开发中，redux中保存的很多数据可能来自服务器，我们需要进行异步的请求，再将数据保存到redux中

网络请求可以在class组件的`componentDidMount`中发送，所以我们可以有这样的结构

![组件中异步操作](https://cdn.jsdelivr.net/gh/bymori/image-PicX@main/img/9sn8ms3nos-1639640082209.png)

```js
// home
import React, { PureComponent } from 'react';

// import { connect } from '../utils/connect';
import { connect } from 'react-redux';

import axios from 'axios';

import {
  incAction,
  addAction,
  changeBannersAction,
  changeRecommendAction,
} from '../store/actionCreators';

class Home extends PureComponent {
  componentDidMount() {
    axios({
      url: 'http://123.207.32.32:8000/home/multidata',
    }).then((res) => {
      const data = res.data.data;
      // console.log('轮播图：', data.banner.list);
      // console.log('推荐：', data.recommend.list);
      this.props.changeBanners(data.banner.list);
      this.props.changeRecommends(data.recommend.list);
    });
  }

  render() {
    return (
      <div>
        <h1>Home3</h1>
        <h2>当前计数: {this.props.counter}</h2>
        <button onClick={(e) => this.props.incAction()}>+1</button>
        <button onClick={(e) => this.props.addAction(5)}>+5</button>
      </div>
    );
  }
}

const mapStateToProps = (state) => {
  return {
    counter: state.counter,
  };
};

const mapDispatchToProps = (dispatch) => ({
  incAction: function () {
    dispatch(incAction());
  },
  addAction: function (num) {
    dispatch(addAction(num));
  },
  changeBanners(banners) {
    dispatch(changeBannersAction(banners));
  },
  changeRecommends(recommends) {
    dispatch(changeRecommendAction(recommends));
  },
});

export default connect(mapStateToProps, mapDispatchToProps)(Home);


// about
// ...
<h1>Banner</h1>
<ul>
  {props.banners.map((item, index) => {
    return <li key={item.acm}>{item.title}</li>;
  })}
</ul>

<h1>Recommend</h1>
<ul>
  {props.recommends.map((item, index) => {
    return <li key={item.acm}>{item.title}</li>;
  })}
</ul>

const mapStateToProps = (state) => {
  return {
    counter: state.counter,
    banners: state.banners,
    recommends: state.recommends,
  };
};
```

**上面的代码有一个缺陷**：

- 必须将网络请求的异步代码放到组件的生命周期中来完成
- 事实上，网络请求到的数据也属于我们状态管理的一部分，更好的一种方式应该是将其也交给redux来管理

![image-20211216155405653](https://cdn.jsdelivr.net/gh/bymori/image-PicX/typora/image-20211216155405653.png)

**但是在redux中如何可以进行异步的操作呢？**

- 答案就是使用**中间件（Middleware）**
- 学习Express或Koa框架也是有中间件的
- 在这类框架中，Middleware可以帮助我们在请求和响应之间嵌入一些操作的代码，比如cookie解析、日志记录、文件压缩等操作

## 理解中间件

redux也引入了**中间件（Middleware）**的概念：

- 这个中间件的目的是在dispatch的action和最终达到的reducer之间，扩展一些自己的代码；
- 比如日志记录、调用异步接口、添加代码调试功能等等；

我们现在要做的事情就是**发送异步的网络请求**，所以我们可以添加对应的中间件：

- 这里官网推荐的、包括演示的网络请求的中间件是使用 redux-thunk；

**redux-thunk是如何做到让我们可以发送异步的请求呢？**

- 默认情况下的`dispatch(action)`，action需要是一个`JavaScript的对象`
- `redux-thunk`可以`dispatch(action函数)`，action**可以是一个函数**
- 该函数会被调用，并且会传给这个函数一个dispatch函数和getState函数
- `dispatch`函数用于我们之后再次派发`action`
- `getState`函数考虑到我们之后的一些操作需要依赖原来的状态，用于让我们可以获取之前的一些状态

### 如何使用redux-thunk

安装**redux-thunk**

```shell
yarn add redux-thunk
```

在创建store时传入应用了middleware的enhance函数

- 通过`applyMiddleware`来结合多个`Middleware`, 返回一个enhancer；
- 将enhancer作为第二个参数传入到createStore中

```js
// store/index.js

import { applyMiddleware } from 'redux';

// composeEnhancers函数 用于REDUX_DEVTOOLS 调试相关
const composeEnhancers =
  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({ trace: true }) || compose;

const storeEnhancer = applyMiddleware(thunkMiddleware);

const store = createStore(reducer, composeEnhancers(storeEnhancer));
```

定义返回一个函数的action：

- 注意：这里不是返回一个对象了，而是一个函数；
- 该函数在dispatch之后会被执行

```js
// store/actionCreators.js

// redux-thunk中定义的action函数
export const getHomeMultidataAction = (dispatch) => {
  axios({
    url: 'http://123.207.32.32:8000/home/multidata',
  }).then((res) => {
    const data = res.data.data;
    dispatch(changeBannersAction(data.banner.list));
    dispatch(changeRecommendAction(data.recommend.list));
  });
};
```

### redux-devtools

redux可以方便的让我们对状态进行跟踪和调试，那么如何做到呢？

- redux官网为我们提供了redux-devtools的工具；
- 利用这个工具，我们可以知道每次状态是如何被修改的，修改前后的状态变化等等；

安装该工具需要两步：

- **第一步**：在对应的浏览器中安装相关的插件（比如Chrome浏览器扩展商店中搜索Redux DevTools即可，其他方法可以参考GitHub）；
- **第二步**：在redux中继承devtools的中间件；

```js
import { createStore, applyMiddleware, compose } from 'redux';

import thunkMiddleware from 'redux-thunk';

import reducer from './reducer.js';

// composeEnhancers函数 用于REDUX_DEVTOOLS 调试相关
const composeEnhancers =
  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({ trace: true }) || compose;

const storeEnhancer = applyMiddleware(thunkMiddleware);

const store = createStore(reducer, composeEnhancers(storeEnhancer));
```

### redux-saga的使用

saga中间件使用了ES6的[generator语法](../06.其他相关补充/02.generator.md) 

redux-saga是另一个比较常用在redux发送异步请求的中间件，它的使用更加的灵活

安装**redux-saga**

```js
yarn add redux-saga
```

集成redux-saga中间件

- 导入创建中间件的函数；
- 通过创建中间件的函数，创建中间件，并且放到applyMiddleware函数中；
- 启动中间件的监听过程，并且传入要监听的saga

```js
import createSagaMiddleware from 'redux-saga';

import saga from './saga';

// 2.创建sagaMiddleware中间件
const sagaMiddleware = createSagaMiddleware();

// 1.引入thunkMiddleware中间件(上面)
const storeEnhancer = applyMiddleware(thunkMiddleware, sagaMiddleware);

const store = createStore(reducer, composeEnhancers(storeEnhancer));

sagaMiddleware.run(saga);
```

**saga.js**文件的编写

- takeEvery：可以传入多个监听的actionType，每一个都可以被执行（对应有一个takeLatest，会取消前面的）
- put：在saga中派发action不再是通过dispatch，而是通过put
- all：可以在yield的时候put多个action

```js
import { takeEvery, put, all, takeLatest } from 'redux-saga/effects';
import axios from 'axios';

import { FETCH_HOME_MULTIDATA, ADD_NUMBER } from './constants';

import { changeBannersAction, changeRecommendAction } from './actionCreators';

function* fetchHomeMultidata(action) {
  const res = yield axios.get('http://123.207.32.32:8000/home/multidata');

  const banners = res.data.data.banner.list;
  const recommends = res.data.data.recommend.list;

  //   yield put(changeBannersAction(banners));
  //   yield put(changeRecommendAction(recommends));

  yield all([
    yield put(changeBannersAction(banners)),
    yield put(changeRecommendAction(recommends)),
  ]);

  console.log(banners, recommends);
}

function* mySaga() {
  // takeLatest takeEvery 区别:
  // takeLatest: 一次只能监听一个对应的action 只会执行最后一个 前面的被覆盖
  // takeEvery: 每一个都会被执行

  yield all([
    takeLatest(FETCH_HOME_MULTIDATA, fetchHomeMultidata),
    // takeLatest(ADD_NUMBER, fetchHomeMultidata),
  ]);
}

export default mySaga;

// export default 生成器函数;
```

## 打印日志需求

中间件的目的是在redux中插入一些自己的操作

- 比如我们现在有一个需求，在`dispatch`之前，打印一下本次的action对象，dispatch完成之后可以打印一下最新的store state
- 也就是我们需要将对应的代码插入到redux的某部分，让之后所有的dispatch都可以包含这样的操作

如果**没有中间件**，是否可以实现类似的代码呢 可以在派发的前后进行相关的打印。

第一种 但是这种方式缺陷非常明显：

- 首先，每一次的dispatch操作，我们都需要在前面加上这样的逻辑代码；
- 其次，存在大量重复的代码，会非常麻烦和臃肿；

第二种 是否有一种更优雅的方式来处理这样的相同逻辑呢？

- 我们可以将代码封装到一个独立的函数中

但是这样的代码有一个**非常大的缺陷**：

- 调用者（使用者）在使用我的dispatch时，必须使用我另外封装的一个函数dispatchAndLog
- 显然，对于调用者来说，很难记住这样的API，更加习惯的方式是直接调用`dispatch`


```js
import store from './store/index.js';

import {
  addAction,
} from './store/actionCreators.js';

store.subscribe(() => {
  console.log(store.getState());
});

// 1.基本做法 -- 这样做简单但是调用起来很复杂
console.log('dispatch前---dispatching action:', addAction(10));
store.dispatch(addAction(10));
console.log('dispatch后---new state:', store.getState());

console.log('dispatch前---dispatching action:', addAction(15));
store.dispatch(addAction(15));
console.log('dispatch后---new state:', store.getState());

// 2.封装一个函数 -- 使用 dispatch 时 就必须使用 dispatchAndLogging 才可以
function dispatchAndLogging(action) {
  console.log('dispatch前---dispatching action:', action);
  store.dispatch(action);
  console.log('dispatch后---new state:', store.getState());
}
dispatchAndLogging(addAction(10));
dispatchAndLogging(addAction(5));
```

**修改dispatch**

事实上，我们可以利用一个hack一点的技术：Monkey Patching，利用它可以修改原有的程序逻辑

**我们对代码进行如下的修改：**

- 这样就意味着我们已经直接修改了dispatch的调用过程；
- 在调用dispatch的过程中，真正调用的函数其实是`dispatchAndLog`

当然，我们可以将它封装到一个模块中，只要调用这个模块中的函数，就可以对store进行这样的处理：

```js
// 3.函数的基础之上进行优化: 修改原有的dispatch
// hack技术: Monkey Patch
// 这就不会影响原来的调用，也就是 Monkey Patch 但是可能污染了原来的store

const next = store.dispatch;
function dispatchAndLogging(action) {
  console.log('dispatch前---dispatching action:', action);
  next(action);
  console.log('dispatch后---new state:', store.getState());
}
store.dispatch = dispatchAndLogging;

dispatchAndLogging(addAction(10));
dispatchAndLogging(addAction(5));

// 4.将之前的操作进行封装
// 封装patchLogging的代码
function patchLogging(store) {
  const next = store.dispatch;
  function dispatchAndLogging(action) {
    console.log('dispatch前---dispatching action:', action);
    next(action);
    console.log('dispatch后---new state:', store.getState());
  }

  store.dispatch = dispatchAndLogging;
}

```

**thunk需求**

redux-thunk的作用：

- 我们知道redux中利用一个中间件redux-thunk可以让我们的dispatch不再只是处理对象，并且可以处理函数；
- 那么redux-thunk中的基本实现过程是怎么样的呢？事实上非常的简单。
- 对dispatch进行转换，这个dispatch会判断传入的

```js
// 封装patchThunk的功能
function patchThunk(store) {
  const next = store.dispatch;

  function dispatchAndThunk(action) {
    if (typeof action === 'function') {
      action(store.dispatch, store.getState);
    } else {
      next(action);
    }
  }

  store.dispatch = dispatchAndThunk;
}

```

**合并中间件**

单个调用某个函数来合并中间件并不是特别的方便，我们可以封装一个函数来实现所有的中间件合并

```js
// 5.封装applyMiddleware 合并中间件
function applyMiddlewares(...middlewares) {
  // const newMiddleware = [...middlewares];
  middlewares.forEach((middleware) => {
    store.dispatch = middleware(store);
  });
}

applyMiddlewares(patchLogging, patchThunk);

store.dispatch(addAction(10));
```

上述的代码流程

![image-20211216163258305](https://cdn.jsdelivr.net/gh/bymori/image-PicX/typora/image-20211216163258305.png)

## Reducer代码拆分

来看一下目前的reducer：

- 当前这个reducer既有处理counter的代码，又有处理home页面的数据；
- 后续counter相关的状态或home相关的状态会进一步变得更加复杂；
- 也会继续添加其他的相关状态，比如购物车、分类、歌单等等；
- 如果将所有的状态都放到一个reducer中进行管理，随着项目的日趋庞大，必然会造成代码臃肿、难以维护。

因此，我们可以对reducer进行**拆分**：

- 我们先抽取一个对counter处理的reducer；
- 再抽取一个对home处理的reducer；
- 将它们合并起来

### Reducer文件拆分

```js
./store
├── counter
│    ├── actionCreators.js
│    ├── constants.js
│    ├── index.js
│    └── reducer.js
├── home
│    ├── actionCreators.js
│    ├── constants.js
│    ├── index.js
│    └── reducer.js
├── index.js
├── reducer.js
└── saga.js
```

### combineReducers函数

目前我们合并的方式是通过每次调用reducer函数自己来返回一个新的对象。

事实上，redux给我们提供了一个`combineReducers`函数可以方便的让我们对多个reducer进行合并

```js
import { reducer as counterReducer } from './counter';
import { reducer as homeReducer } from './home';

import { combineReducers } from 'redux';

// function reducer(state = {}, action) {
//   return {
//     counterInfo: counterReducer(state.counterInfo, action),
//     homeInfo: homeReducer(state.homeInfo, action),
//   };
// }

//reducer应该是一个 function 类型?
const reducer = combineReducers({
  counterInfo: counterReducer,
  homeInfo: homeReducer,
});

export default reducer;
```

那么combineReducers是如何实现的呢？

- 事实上，它也是将传入的reducers合并到一个对象中，最终返回一个combination的函数（相当于我们之前的reducer函数了）
- 在执行combination函数的过程中，它会通过判断前后返回的数据是否相同来决定返回之前的state还是新的state
- 新的state会触发订阅者发生对应的刷新，而旧的state可以有效的组织订阅者发生刷新