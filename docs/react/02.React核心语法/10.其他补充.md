---
title: 其他补充
date: 2021-12-15 16:19:21
permalink: /pages/9d824d/
categories:
  - react
  - React核心语法
tags:
  - 
---
## 其他补充

- Portals的使用
- fragment
- strictMode的使用
  
<!-- more -->

## Portals的使用

- 某些情况下，我们希望渲染的内容独立于父组件，甚至是独立于当前挂载到的DOM元素中（默认都是挂载到id为root的DOM元素上的）。
  - Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案：
    - 第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 fragment；
    - 第二个参数（container）是一个 DOM 元素

```js
ReactDOM.createPortal(child,container);
```

- 当你从组件的 render 方法返回一个元素时，该元素将被挂载到 DOM 节点中离其最近的父节点：
- 然而，有时候将子元素插入到 DOM 节点中的不同位置也是有好处的

```js
class Modal extends PureComponent {
  render() {
    return ReactDOM.createPortal(
      this.props.children,
      document.getElementById('modal')
    );
  }
}

class Home extends PureComponent {
  render() {
    return (
      <div>
        <h2>Home</h2>
        <Modal>
          <h2>Title</h2>
        </Modal>
      </div>
    );
  }
}
```

## fragment

- 在之前的开发中，我们总是在一个组件中返回内容时包裹一个div元素：
- 我们又希望可以不渲染这样一个div应该如何操作呢？
  - 使用`Fragment`
  - `Fragment` 允许你将子列表分组，而无需向 DOM 添加额外节点；
- React还提供了`Fragment`的短语法：
  - 它看起来像空标签 <> </>；
  - 但是，如果我们需要在Fragment中添加key，那么就不能使用短语法
  - 但是!!! 短语法中不能添加任何的属性

```js
import React, { PureComponent, Fragment } from 'react';

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0,
      friends: [
        { name: 'Phyllis', age: 18 },
        { name: 'Pearl', age: 20 },
        { name: 'Rosemarie', age: 25 },
      ],
    };
  }

  render() {
    return (
      // <Fragment> ** </Fragment> === <> ** </> 短语法
      // 但是!!! 短语法中不能添加任何的属性
      // <Fragment key={item.name}> √
      // < key={item.name}> ×

      //   <Fragment>
      //     <h2>当前计数: {this.state.counter}</h2>
      //     <button onClick={(e) => this.increment()}>+1</button>
      //   </Fragment>

      <>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={(e) => this.increment()}>+1</button>

        <div>
          {this.state.friends.map((item, index) => {
            return (
              <Fragment key={item.name}>
                <div>{item.name}</div>
                <p>{item.age}</p>
                <hr />
              </Fragment>
            );
          })}
        </div>
      </>
    );
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1,
    });
  }
}
```

## strictMode的使用

- StrictMode 是一个用来突出显示应用程序中潜在问题的工具。
  - 与 Fragment 一样，StrictMode 不会渲染任何可见的 UI；
  - 它为其后代元素触发额外的检查和警告；
  - 严格模式检查仅在开发模式下运行；它们不会影响生产构建

### 严格模式检查的是什么

**但是检测，到底检测什么呢？**

1. 识别不安全的生命周期
2. 使用过时的ref API
3. 使用废弃的findDOMNode方法
   1. 在之前的React API中，可以通过findDOMNode来获取DOM，不过已经不推荐使用了，可以自行学习演练一下
4. 检查意外的副作用
   1. 这个组件的constructor会被调用两次
   2. 这是严格模式下故意进行的操作，让你来查看在这里写的一些逻辑代码被调用多次时，是否会产生一些副作用
   3. 在生产环境中，是不会被调用两次的
5. 检测过时的context API
   1. 早期的Context是通过static属性声明Context对象属性，通过getChildContext返回Context对象等方式来使用Context的
   2. 目前这种方式已经不推荐使用，大家可以自行学习了解一下它的用法
