---
title: React组件化开发
date: 2021-12-13 15:05:30
permalink: /pages/d7b582/
categories:
  - react
  - React核心语法
tags:
  - 
---
## 什么是组件化开发呢？

任何一个人处理信息的逻辑能力都是有限的

所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。

如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解

<!-- more -->

- 组件化也是类似的思想
  - 如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展。
  - 但如果，我们讲一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了。
- 我们需要通过组件化的思想来思考整个应用程序：
  - 我们将一个完整的页面分成很多个组件；
  - 每个组件都用于实现页面的一个功能块；
  - 而每一个组件又可以进行细分；
  - 而组件本身又可以在多个地方进行复用；

### React的组件化

组件化是React的核心思想，前面封装的App本身就是一个组件：

- 组件化提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。
- 任何的应用都会被抽象成一颗组件树

![React的组件化](https://cdn.jsdelivr.net/gh/bymori/image-PicX@main/img/0jv461ks9i-1639360989464.png)

组件化思想的应用：

- 有了组件化的思想，我们在之后的开发中就要充分的利用它。
- 尽可能的将页面拆分成一个个小的、可复用的组件。
- 这样让我们的代码更加方便组织和管理，并且扩展性也更强

React的组件相对于Vue更加的灵活和多样，按照不同的方式可以分成很多类组件：

- 根据组件的定义方式，可以分为：**函数组件(Functional Component )**和**类组件(Class Component)**
- 根据组件内部是否有状态需要维护，可以分成：**无状态组件(Stateless Component )**和**有状态组件(Stateful Component)**
- 根据组件的不同职责，可以分成：**展示型组件(Presentational Component)**和**容器型组件(Container Component)**

这些概念有很多重叠，但是他们最主要是关注数据逻辑和UI展示的分离：

- 函数组件、无状态组件、展示型组件主要关注UI的展示；
- 类组件、有状态组件、容器型组件主要关注数据逻辑；

## 类组件

- 类组件的定义有如下要求：
  - 组件的名称是`大写字符开头`（无论类组件还是函数组件）
  - 类组件需要继承自 `React.Component`
  - 类组件必须实现render函数
- 在ES6之前，可以通过`create-react-class` 模块来定义类组件
- 使用class定义一个组件：
  - `constructor`是可选的，我们通常在constructor中初始化一些数据；
  - `this.state`中维护的就是我们组件内部的数据；
  - `render()` 方法是 class 组件中唯一必须实现的方法

```js
export default class App extends Component {
  render() {
    return (
      <div>
        <span>我是App组件</span>
        <span>我是App组件</span>
        <span>我是App组件</span>
      </div>
    );
  }
}
```

### render函数的返回值

- 当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回以下类型之一：
- **React 元素**：
  - 通常通过 `JSX` 创建。
  - 例如，`<div />` 会被 React 渲染为 DOM 节点，`<MyComponent />` 会被 React 渲染为自定义组件；
  - 无论是 `<div />` 还是 `<MyComponent />` 均为 React 元素。
- **数组或 fragments**：使得 render 方法可以返回多个元素。
- **Portals**：可以渲染子节点到不同的 DOM 子树中。
- **字符串或数值类型**：它们在 DOM 中会被渲染为文本节点
- **布尔类型或 null**：什么都不渲染

## 函数组件

- 函数组件是使用function来进行定义的函数，只是这个函数会返回和类组件中render函数返回一样的内容。
- 函数组件有自己的特点
  - 没有生命周期，也会被更新并挂载，但是没有生命周期函数
  - 没有this(组件实例）
  - 没有内部状态（state）  (使用hooks)

```js
export default function App() {
  return (
    <div>
      <span>我是function的组件: App组件</span>
      <h2>counter</h2>
      <button>+1</button>
      <h2>哈喽 沫沫</h2>
    </div>
  );
}
```

## React生命周期

- 很多的事物都有从创建到销毁的整个过程，这个过程称之为是**生命周期**
- React组件也有自己的生命周期，了解组件的生命周期可以让我们在最合适的地方完成自己想要的功能
- 生命周期和生命周期函数的关系：
- 生命周期是一个抽象的概念，在生命周期的整个过程，分成了很多个阶段
  - 比如装载阶段（**Mount**），组件第一次在DOM树中被渲染的过程；
  - 比如更新过程（**Update**），组件状态发生变化，重新更新渲染的过程；
  - 比如卸载过程（**Unmount**），组件从DOM树中被移除的过程
- React内部为了告诉我们当前处于哪些阶段，会对我们组件内部实现的某些函数进行回调，这些函数就是生命周期函数：
  - 比如实现`componentDidMount`函数：组件已经挂载到DOM上时，就会回调；
  - 比如实现`componentDidUpdate`函数：组件已经发生了更新时，就会回调；
  - 比如实现`componentWillUnmount`函数：组件即将被移除时，就会回调；
  - 我们可以在这些回调函数中编写自己的逻辑代码，来完成自己的需求功能；
- 我们谈React生命周期时，主要谈的类的生命周期，因为函数式组件是没有生命周期函数的；（可以通过hooks来模拟一些生命周期的回调）

![生命周期图谱](https://cdn.jsdelivr.net/gh/bymori/image-PicX@main/img/lnh6siwctc-1639386097846.png)
[生命周期图谱](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

**Constructor**

- 如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。
- constructor中通常只做两件事情：
  - 通过给 this.state 赋值对象来初始化内部的state
  - 为事件绑定实例（this）

```js
  constructor() {
    super();

    this.state = {
      counter: 0,
      isShow: true,
    };

    console.log('执行了组件的 constructor 方法');
  }
```

**componentDidMount**

- componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。
- componentDidMount中通常进行哪里操作呢？
  - 依赖于DOM的操作可以在这里进行；
  - 在此处发送网络请求就最好的地方；（官方建议）
  - 可以在此处添加一些订阅（会在componentWillUnmount取消订阅）；

```js
  componentDidMount() {
    // 组件挂载完成
    console.log('执行了组件的 componentDidMount 方法');
  }
```

**componentDidUpdate**

- componentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。
  - 当组件更新后，可以在此处对 DOM 进行操作；
  - 如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。

```js
  componentDidUpdate(prevProps, prevState, snapshot) {
    console.log('执行了组件的 componentDidUpdate 方法');
    console.log('prevProps: ', prevProps);
    console.log('prevState: ', prevState);
    console.log('snapshot: ', snapshot);
  }
```

**componentWillUnmount**

- componentWillUnmount() 会在组件卸载及销毁之前直接调用。
  - 在此方法中执行必要的清理操作；
  - 例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等

```js
  componentWillUnmount() {
    console.log('调用了Cpn的 componentWillUnmount 方法');
  }
```

### 不常用生命周期函数

![生命周期图谱](https://cdn.jsdelivr.net/gh/bymori/image-PicX@main/img/qu62xtrmj6-1639395533574.png)
[生命周期图谱](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

除了上面介绍的生命周期函数之外，还有一些不常用的生命周期函数：

- **getDerivedStateFromProps**：state 的值在任何时候都依赖于 props时使用；该方法返回一个对象来更新state；
- **getSnapshotBeforeUpdate**：在React更新DOM之前回调的一个函数，可以获取DOM更新前一些信息（比如说滚动位置）；
- **shouldComponentUpdate**：该生命周期函数很常用，但是我们等待讲性能优化时再来详细讲解


## 认识组件的嵌套

组件之间存在嵌套关系

- 在之前的案例中，我们只是创建了一个组件App；
- 如果我们一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护；
- 所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件；
- 再将这些组件组合嵌套在一起，最终形成我们的应用程序

## 认识组件间的通信

- 在开发过程中，我们会经常遇到需要组件之间相互进行通信：
  - 比如App可能使用了多个Header，每个地方的Header展示的内容不同，那么我们就需要使用者传递给Header一些数据，让其进行展示；
  - 又比如我们在Main中一次性请求了Banner数据和ProductList数据，那么就需要传递给他们来进行展示；
  - 也可能是子组件中发生了事件，需要由父组件来完成某些操作，那就需要子组件向父组件传递事件；
- 总之，在一个React项目中，组件之间的通信是非常重要的环节

## 参数propTypes

- 对于传递给子组件的数据，有时候我们可能希望进行验证，特别是对于大型项目来说：
  - 当然，如果你项目中默认继承了Flow或者TypeScript，那么直接就可以进行类型验证；
  - 但是，即使我们没有使用Flow或者TypeScript，也可以通过 prop-types 库来进行参数验证；
- 从 React v15.5 开始，React.PropTypes 已移入另一个包中：`prop-types 库`

- 更多的验证方式，可以参考官网：[https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html](https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html)
  - 比如验证数组，并且数组中包含哪些元素；
  - 比如验证对象，并且对象中包含哪些key以及value是什么类型；
  - 比如某个原生是必须的，使用 requiredFunc: PropTypes.func.isRequired
- 如果没有传递，我们希望有默认值呢？
  - 使用defaultProps就可以了

```js
import React, { Component } from 'react';
import PropTypes from 'prop-types';

class ChildCpn2 extends Component {
  // es6中的 class fields 写法
  static propTypes = {};

  static defaultProps = {};
}

function ChildCpn(props) {
  console.log(props);

  const { name, age, height } = props;
  const { names } = props;

  return (
    <div>
      <h2>子组件展示数据: {name + ' ' + age + ' ' + height}</h2>
      <ul>
        {names.map((item, index) => {
          return <li>{item}</li>;
        })}
      </ul>
    </div>
  );
}

ChildCpn.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
  height: PropTypes.number,
  names: PropTypes.array,
};
ChildCpn.defaultProps = {
  name: '默认值',
  age: 30,
  height: 1.88,
  names: ['aaa', 'bbb'],
};

export default class App extends Component {
  render() {
    return (
      <div>
        <ChildCpn name="momo" age={19} height={1.78} names={['abc', 'cba']} />
        <ChildCpn name="mori" age={26} height={1.69} names={['nba', 'mba']} />
        <ChildCpn />
      </div>
    );
  }
}
```

### 父传子通信

- 父组件在展示子组件，可能会传递一些数据给子组件
  - 父组件通过 **属性=值** 的形式来传递给子组件数据
  - 子组件通过 **props** 参数获取父组件传递过来的数据

#### 父传子通信-类组件

```js
import React, { Component } from 'react';

class ChildCpn extends Component {
  constructor(props) {
    super(props);

    this.props = props;
  }

  componentDidMount() {
    console.log('componentDidMount: ', this.props);
  }

  render() {
    console.log(this.props, 'render');
    const { name, age, height } = this.props;
    return <h2>子组件展示数据: {name + ' ' + age + ' ' + height}</h2>;
  }
}

export default class App extends Component {
  render() {
    return (
      <div>
        <ChildCpn name="momo" age="19" height="1.78" />
        <ChildCpn name="mori" age="26" height="1.69" />
      </div>
    );
  }
}
```

#### 父传子通信-函数组件

```js
import React, { Component } from 'react';

function ChildCpn(props) {
  console.log(props);

  const { name, age, height } = props;

  return <h2>子组件展示数据: {name + ' ' + age + ' ' + height}</h2>;
}

export default class App extends Component {
  render() {
    return (
      <div>
        <ChildCpn name="momo" age="19" height="1.78" />
        <ChildCpn name="mori" age="26" height="1.69" />
      </div>
    );
  }
}
```

### 子组件传递父组件

- 某些情况，我们也需要子组件向父组件传递消息：
  - 在vue中是通过自定义事件来完成的；
  - 在React中同样是通过props传递消息，只是让父组件给子组件传递一个回调函数，在子组件中调用这个函数即可；

```js
import React, { Component } from 'react';

class CounterButton extends Component {
  render() {
    const { btnIncrement } = this.props;
    return <button onClick={btnIncrement}>+1</button>;
  }
}

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0,
    };
  }

  render() {
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={(e) => this.increment()}>+</button>
        <CounterButton btnIncrement={(e) => this.increment()} name="momo" />
      </div>
    );
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1,
    });
  }
}
```

## 跨组件的通信

- 非父子组件数据的共享：
  - 在开发中，比较常见的数据传递方式是通过props属性自上而下（由父到子）进行传递。
  - 但是对于有一些场景：比如一些数据需要在多个组件中进行共享（地区偏好、UI主题、用户登录状态、用户信息等）。
  - 如果我们在顶层的App中定义这些信息，之后一层层传递下去，那么对于一些中间层不需要数据的组件来说，是一种冗余的操作

```js
import React, { Component } from 'react';

function ProfileHeader(props) {
  return (
    <div>
      <h2>用户昵称: {props.nickname}</h2>
      <h2>用户等级: {props.level}</h2>
    </div>
  );
}

function Profile(props) {
  return (
    <div>
      {/* <ProfileHeader nickname={props.nickname} level={props.level} /> */}

      <ProfileHeader {...props} />
      <ul>
        <li>设置1</li>
        <li>设置2</li>
        <li>设置3</li>
        <li>设置4</li>
      </ul>
    </div>
  );
}

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      nickname: 'momo',
      level: 99,
    };
  }

  render() {
    const { nickname, level } = this.state;

    return (
      <div>
        <Profile nickname={nickname} level={level} />
        <hr />
        <Profile {...this.state} />
      </div>
    );
  }
}
```

- 但是，如果层级更多的话，一层层传递是非常麻烦，并且代码是非常冗余的：
  - React提供了一个API：Context；
  - Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props；
  - Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言

### Context相关API

- **React.createContext**
  - 创建一个需要共享的Context对象：
  - 如果一个组件订阅了Context，那么这个组件会从离自身最近的那个匹配的 Provider 中读取到当前的context值；
  - defaultValue是组件在顶层查找过程中没有找到对应的Provider，那么就使用默认值

```js
// 创建Context对象
const UserContext = React.createContext({
  nickname: 'aaaa',
  level: -1,
});
```

- **Context.Provider**
  - 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化：
  - Provider 接收一个 **value** 属性，传递给消费组件；
  - 一个 Provider 可以和多个消费组件有对应关系；
  - 多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据；
  - 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染

```js
 <UserContext.Provider value={this.state}>
```

- **Class.contextType**
  - 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象：
  - 这能让你使用 this.context 来消费最近 Context 上的那个值；
  - 你可以在任何生命周期中访问到它，包括 render 函数中；

```js
ProfileHeader.contextType = UserContext;
```

- **Context.Consumer**
  - 这里，React 组件也可以订阅到 context 变更。这能让你在 函数式组件 中完成订阅 context。
  - 这里需要 函数作为子元素（function as child）这种做法；
  - 这个函数接收当前的 context 值，返回一个 React 节点

```js
    <UserContext.Consumer>
      {(value) => { // 基于 context 的值进行渲染 }}
    </UserContext.Consumer>
```

### Context使用

```js
import React, { Component } from 'react';

// 创建Context对象
const UserContext = React.createContext({
  nickname: 'aaaa',
  level: -1,
});
const ThemeContext = React.createContext({
  color: 'black',
});

function ProfileHeader() {
  return (
    <UserContext.Consumer>
      {(value) => {
        return (
          <ThemeContext.Consumer>
            {(theme) => {
              return (
                <div>
                  <h2 style={{ color: theme.color }}>
                    用户昵称: {value.nickname}
                  </h2>
                  <h2>用户等级: {value.level}</h2>
                  <h2>颜色: {theme.color}</h2>
                </div>
              );
            }}
          </ThemeContext.Consumer>
        );
      }}
    </UserContext.Consumer>
  );
}

function Profile(props) {
  return (
    <div>
      <ProfileHeader />
      <ul>
        <li>设置1</li>
        <li>设置2</li>
        <li>设置3</li>
        <li>设置4</li>
      </ul>
    </div>
  );
}

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      nickname: 'momo',
      level: 99,
    };
  }

  render() {
    return (
      <div>
        <UserContext.Provider value={this.state}>
          <ThemeContext.Provider value={{ color: 'red' }}>
            <Profile />
          </ThemeContext.Provider>
        </UserContext.Provider>

        <hr />
        <Profile />
      </div>
    );
  }
}
```

### 事件总线

- 通过Context主要实现的是数据的共享，但是在开发中如果有跨组件之间的事件传递，应该如何操作呢？
  - 在Vue中我们可以通过Vue的实例，快速实现一个事件总线（EventBus），来完成操作；
  - 在React中，我们可以依赖一个使用较多的库 `events` 来完成对应的操作

```shell
yarn add events
```

- events常用的API：
  - 创建EventEmitter对象：eventBus对象；
  - 发出事件：`eventBus.emit("事件名称", 参数列表)`
  - 监听事件：`eventBus.addListener("事件名称", 监听函数)`
  - 移除事件：`eventBus.removeListener("事件名称", 监听函数)`

```js
import React, { PureComponent } from 'react';

import { EventEmitter } from 'events';
// 事件总线: event bus
const eventBus = new EventEmitter();

class Home extends PureComponent {
  componentDidMount() {
    eventBus.addListener('sayHello', this.handleSayHelloListener);
  }

  componentWillUnmount() {
    eventBus.removeListener('sayHello', this.handleSayHelloListener);
  }

  handleSayHelloListener(num, message) {
    console.log(num, message);
  }

  render() {
    return <div>Home</div>;
  }
}
class Profile extends PureComponent {
  render() {
    return (
      <div>
        Profile
        <button onClick={(e) => this.emitEvent()}>点击了profile按钮</button>
      </div>
    );
  }

  emitEvent() {
    eventBus.emit('sayHello', 123, 'Hello Home');
  }
}
export default class App extends PureComponent {
  render() {
    return (
      <div>
        <Home />
        <Profile />
      </div>
    );
  }
}
```

## setState的使用

### 为什么使用setState

- 开发中我们并不能直接通过修改state的值来让界面发生更新：
  - 因为我们修改了state之后，希望React根据最新的State来重新渲染界面，但是这种方式的修改React并不知道数据发生了变化；
  - React并没有实现类似于Vue2中的`Object.defineProperty`或者Vue3中的`Proxy`的方式来监听数据的变化；
  - 我们必须通过setState来告知React数据已经发生了变化；
- 疑惑：在组件中并没有实现setState的方法，为什么可以调用呢？
  - 原因很简单，setState方法是从Component中继承过来的。

### setState异步更新

- setState的更新是异步的？
  - setState是异步的操作，我们并不能在执行完setState之后立马拿到最新的state的结果

```js
this.setState({
  message: '哈喽 沫沫',
});
console.log(this.state.message); // Hello World
```

- setState设计为异步，可以显著的提升性能
  - 如果每次调用 setState都进行一次更新，那么意味着render函数会被频繁调用，界面重新渲染，这样效率是很低的；
  - 最好的办法应该是获取到多个更新，之后进行批量更新；
- 如果同步更新了state，但是还没有执行render函数，那么state和props不能保持同步；
  - state和props不能保持一致性，会在开发中产生很多的问题

#### 那么如何可以获取到更新后的值呢？

- **方式一：setState的回调**
  - setState接受两个参数：第二个参数是一个回调函数，这个回调函数会在更新后会执行；
  - 格式如下：`setState(partialState, callback)`

```js
// 方式一:  获取异步更新后的数据
// setState(更新的state, 回调函数)
// 类似于 Vue 中的 nextTick
this.setState(
  {
    message: '哈喽 沫沫',
  },
  () => {
    console.log('changeText: ', this.state.message);
  }
);

// 当然，也可以在生命周期函数
componentDidUpdate() {
// 方式二: 获取异步更新的state
  console.log('componentDidUpdate: ', this.state.message);
}
```

#### setState一定是异步吗？

- 其实分成两种情况：
  - 在组件生命周期或React合成事件中，**setState是异步**
  - 在setTimeout或者原生dom事件中，**setState是同步**

```js
changeText() {
  // 情况一: 将setState放入到定时器中
  setTimeout(() => {
    this.setState({
      message: '哈喽 沫沫',
    });
    console.log(this.state.message); // 哈喽 沫沫
  }, 0);
}
```

```js
// 情况二: 原生DOM事件
componentDidMount() {
  document.getElementById('btn').addEventListener('click', (e) => {
    this.setState({
      message: '哈喽 沫沫 2',
    });
    console.log(this.state.message); // 哈喽 沫沫 2
  });

  // this.setState({
  //   message: '哈喽 沫沫 2',
  // });
  // console.log(this.state.message); // Hello World
}
```

### 多个state的合并

比如有一个counter属性，记录当前的数字

```js
  increment() {
    // 1. setState本身被合并 最终 +1
    // this.setState({
    //   counter: this.state.counter + 1,
    // });
    // this.setState({
    //   counter: this.state.counter + 1,
    // });
    // this.setState({
    //   counter: this.state.counter + 1,
    // });
    //
    // 2.setState合并时进行累加  最终 +3
    this.setState((prevState, props) => {
      return {
        counter: prevState.counter + 1,
      };
    });
    this.setState((prevState, props) => {
      return {
        counter: prevState.counter + 1,
      };
    });
    this.setState((prevState, props) => {
      return {
        counter: prevState.counter + 1,
      };
    });
  }
```

## React性能优化

### React的更新流程

React在props或state发生改变时，会调用React的render方法，会创建一颗不同的树

#### 情况一：对比不同类型的元素

- 当节点为不同的元素，React会拆卸原有的树，并且建立起新的树：
  - 当一个元素从 `<a>` 变成 `<img>`，从 `<Article>` 变成 `<Comment>`，或从 `<Button>` 变成 `<div>` 都会触发一个完整的重建流程；
  - 当卸载一棵树时，对应的DOM节点也会被销毁，组件实例将执行 `componentWillUnmount()` 方法；
  - 当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中，组件实例将执行 `componentWillMount()` 方法，紧接着 `componentDidMount()` 方法；

#### 情况二：对比同一类型的元素

当比对两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性

#### 情况三：对子节点进行递归

在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个mutation。

### keys的优化

在前面遍历列表时，总是会提示一个警告，让我们加入一个key属性

- 方式一：在最后位置插入数据
  - 这种情况，有无key意义并不大
- 方式二：在前面插入数据
  - 这种做法，在没有key的情况下，所有的li都需要进行修改；
- 当子元素(这里的li)拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素：
  - 在下面这种场景下，key为111和222的元素仅仅进行位移，不需要进行任何的修改；
  - 将key为333的元素插入到最前面的位置即可；
- key的注意事项：
  - key应该是唯一的；
  - key不要使用随机数（随机数在下一次render时，会重新生成一个数字）；
  - 使用index作为key，对性能是没有优化的；

```js
import React, { Component } from 'react';

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      movies: ['肖申克的救赎', '战狼2'],
    };
  }
  render() {
    return (
      <div>
        <h2>电影列表</h2>
        <ul>
          {this.state.movies.map((item, index) => {
            return <li key={item}>{item}</li>;
          })}
        </ul>
        <button onClick={(e) => this.insertMovie()}>添加电影</button>
      </div>
    );
  }

  insertMovie() {
    // this.setState({
    //   movies: [...this.state.movies, '长津湖'],
    // });
    this.setState({
      movies: ['长津湖', ...this.state.movies],
    });
  }
}
```

### render函数被调用

前面计数器案例中

当点击+1时，会重新调用App的render函数。而当App的render函数被调用时，所有的子组件的render函数都会被重新调用

它们调用render应该有一个前提，就是依赖的数据（state、props）发生改变时，再调用自己的render方法；

这时就可以使用 `shouldComponentUpdate` 方法 来控制render方法是否被调用

#### shouldComponentUpdate

- React给我们提供了一个生命周期方法 `shouldComponentUpdate`（很多时候，我们简称为SCU），这个方法接受参数，并且需要有返回值：
- 该方法有两个参数：
  - 参数一：nextProps 修改之后，最新的props属性
  - 参数二：nextState 修改之后，最新的state属性
- 该方法返回值是一个boolean类型
  - 返回值为true，那么就需要调用render方法；
  - 返回值为false，那么久不需要调用render方法；
  - 默认返回的是true，也就是只要state发生改变，就会调用render方法；
- 比如我们在App中增加一个message属性：
  - jsx中并没有依赖这个message，那么它的改变不应该引起重新渲染；
  - 但是因为render监听到state的改变，就会重新render，所以最后render方法还是被重新调用了；

```js
import React, { Component } from 'react';

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0,
      message: 'Hello World',
    };
  }

  render() {
    console.log('App render函数被调用');
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={(e) => this.increment()}>+1</button>
        <button onClick={(e) => this.changeText()}>改变文本</button>
      </div>
    );
  }

  shouldComponentUpdate(nextProps, nextState) {
    if (this.state.counter !== nextState.counter) {
      return true;
    }

    return false;
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1,
    });
  }
  changeText() {
    this.setState({
      message: '哈喽 沫沫',
    });
  }
}
```

#### PureComponent

- 如果所有的类，我们都需要手动来实现 shouldComponentUpdate，那么会给我们开发者增加非常多的工作量。
  - 我们来设想一下shouldComponentUpdate中的各种判断的目的是什么？
  - props或者state中的数据是否发生了改变，来决定shouldComponentUpdate返回true或者false
- 将class继承自`PureComponent`即可
  - 这个方法中，调用 !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)，这个shallowEqual就是进行浅层比较

```js
export default class App extends PureComponent { ... }
```

### 高阶组件memo

- 我们需要使用一个高阶组件memo：
  - 我们将之前的Header、Banner、ProductList都通过memo函数进行一层包裹；
  - Footer没有使用memo函数进行包裹；
  - 最终的效果是，当counter发生改变时，Header、Banner、ProductList的函数不会重新执行，而Footer的函数会被重新执行；

```js
import React, { PureComponent, memo } from 'react';

// Header
const MemoHeader = memo(function Header() {
  console.log('Header被调用');
  return <h2>我是Header组件</h2>;
});

// Main
class Banner extends PureComponent {
  render() {
    console.log('Banner render函数被调用');
    return <h3>我是Banner组件</h3>;
  }
}

const MemoProductList = memo(function ProductList() {
  console.log('ProductList被调用');
  return (
    <ul>
      <li>商品列表1</li>
      <li>商品列表2</li>
      <li>商品列表3</li>
      <li>商品列表4</li>
      <li>商品列表5</li>
    </ul>
  );
});

class Main extends PureComponent {
  render() {
    console.log('Main render函数被调用');
    return (
      <div>
        <Banner />
        <MemoProductList />
      </div>
    );
  }
}

// Footer
const MemoFooter = memo(function Footer() {
  console.log('Footer被调用');
  return <h2>我是Footer组件</h2>;
});

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0,
    };
  }

  render() {
    console.log('App render函数被调用');
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={(e) => this.increment()}>+1</button>
        <MemoHeader />
        <Main />
        <MemoFooter />
      </div>
    );
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1,
    });
  }
}
```

## 受控和非受控组件

### refs的使用

- 在React的开发模式中，通常情况下不需要、也不建议直接操作DOM原生，但是某些特殊的情况，确实需要获取到DOM进行某些操作：
  - 管理焦点，文本选择或媒体播放；
  - 触发强制动画；
  - 集成第三方 DOM 库

- 如何创建`refs`来获取对应的DOM呢？目前有三种方式
- 方式一：传入字符串
  - 使用时通过 this.refs.传入的字符串格式获取对应的元素；
- 方式二：传入一个对象
  - 对象是通过 React.createRef() 方式创建出来的；
  - 使用时获取到创建的对象其中有一个current属性就是对应的元素；
- 方式三：传入一个函数
  - 该函数会在DOM被挂载时进行回调，这个函数会传入一个 元素对象，我们可以自己保存；
  - 使用时，直接拿到之前保存的元素对象即可；

#### ref的类型

- ref 的值根据节点的类型而有所不同：
  - 当 ref 属性用于 HTML 元素时，构造函数中使用 `React.createRef()` 创建的 ref 接收底层 DOM 元素作为其 current 属性；
  - 当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性；
  - 你**不能**在**函数组件**上使用 ref 属性，因为他们没有实例；

- 函数式组件是没有实例的，所以无法通过ref获取他们的实例：
  - 但是某些时候，我们可能想要获取函数式组件中的某个DOM元素；
  - 这个时候我们可以通过 `React.forwardRef` ，后面学习 hooks 中如何使用ref；

```js
import React, { PureComponent, createRef } from 'react';

class Counter extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0,
    };
  }

  render() {
    return (
      <div>
        <h2>Counter组件 : 当前计数: {this.state.counter}</h2>
        <button onClick={(e) => this.increment()}>+1</button>
      </div>
    );
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1,
    });
  }
}

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.titleRef = createRef();
    this.counterRef = createRef();
    this.titleEl = null;
  }

  render() {
    return (
      <div>
        {/* <h2 ref=字符串/对象/函数>Hello React</h2> */}
        <h2 ref="titleRef">Hello React</h2>
        <button onClick={(e) => this.changeTextOne()}>改变文本 一</button>

        {/* 目前React推荐的方式 */}
        <h2 ref={this.titleRef}>Hello React titleRef</h2>
        <button onClick={(e) => this.changeTextTwo()}>改变文本 二</button>

        {/* 回调函数方式 */}
        <h2 ref={(arg) => (this.titleEl = arg)}>Hello React</h2>
        <button onClick={(e) => this.changeTextThree()}>改变文本 三</button>

        <Counter ref={this.counterRef} />
        <button onClick={(e) => this.appBtnClick()}>App按钮</button>
      </div>
    );
  }

  changeTextOne() {
    // 1.使用方式一: 字符串(不推荐, refs 已废弃 21.11.30)
    this.refs.titleRef.innerHTML = 'Hello momo';
  }

  changeTextTwo() {
    // 2.使用方式二: 对象方式
    this.titleRef.current.innerHTML = 'Hello JavaScript';
  }

  changeTextThree() {
    // 3.使用方式三: 回调函数方式
    this.titleEl.innerHTML = 'Hello TypeScript';
  }

  //   注意 不能在函数组件上使用ref属性，因为他们没有实例；
  appBtnClick() {
    this.counterRef.current.increment();
  }
}
```

### 受控组件的基本使用

在React中，HTML表单的处理方式和普通的DOM元素不太一样：表单元素通常会保存在一些内部的state

- 比如下面的HTML表单元素：
  - 这个处理方式是DOM默认处理HTML表单的行为，在用户点击提交时会提交到某个服务器中，并且刷新页面；
  - 在React中，并没有禁止这个行为，它依然是有效的；
  - 但是通常情况下会使用JavaScript函数来方便的处理表单提交，同时还可以访问用户填写的表单数据；
  - 实现这种效果的标准方式是使用“受控组件”

```js
<form>
  <label>
    用户: <input type="text" name="username" />
  </label>
  <input type="submit" value="提交" />
</form>
```

- 在 HTML 中，表单元素（如`<input>`、 `<textarea>` 和 `<select>`）之类的表单元素通常自己维护 state，并根据用户输入进行更新。
- 而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。
  - 我们将两者结合起来，使React的state成为“唯一数据源”；
  - 渲染表单的 React 组件还控制着用户输入过程中表单发生的操作；
  - 被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”；
- 由于在表单元素上设置了 value 属性，因此显示的值将始终为 `this.state.value`，这使得 React 的 state 成为唯一数据源。
- 由于 handleChange 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。

```js
import React, { PureComponent } from 'react';

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      username: '',
    };
  }

  render() {
    return (
      <div>
        <form onSubmit={(e) => this.handleSubmit(e)}>
          <label htmlFor="username">
            用户: {/* 受控组件 */}
            <input
              type="text"
              id="username"
              onChange={(e) => this.handleChange(e)}
              value={this.state.username}
            />
          </label>
          <input type="submit" value="提交" />
        </form>
      </div>
    );
  }

  handleSubmit(event) {
    event.preventDefault();
    // console.log(event);
    console.log(this.state.username);
  }

  handleChange(event) {
    console.log(event.target.value);
    this.setState({
      username: event.target.value,
    });
  }
}
```

### 非受控组件

- React推荐大多数情况下使用 受控组件 来处理表单数据：
  - 一个受控组件中，表单数据是由 React 组件来管理的；
  - 另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理；
- 如果要使用非受控组件中的数据，那么我们需要使用 ref 来从DOM节点中获取表单数据。
- 在非受控组件中通常使用`defaultValue`来设置默认值；
- 同样，`<input type="checkbox">` 和 `<input type="radio">` 支持 `defaultChecked`，`<select>` 和 `<textarea>` 支持 `defaultValue`

```js
import React, { PureComponent, createRef } from 'react';

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.usernameRef = createRef();
  }

  render() {
    return (
      <div>
        <form onSubmit={(e) => this.handleSubmit(e)}>
          <label htmlFor="username">
            用户:
            <input type="text" id="username" ref={this.usernameRef} />
          </label>
          <input type="submit" value="提交" />
        </form>
      </div>
    );
  }

  handleSubmit(event) {
    event.preventDefault();
    console.log(this.usernameRef.current.value);
  }
}
```

## 高阶组件的使用

**什么是高阶组件呢？**

- JavaScript中比较常见的`filter`、`map`、`reduce`都是高阶函数。
- 如何说明是高阶组件呢？
  - 高阶组件的英文是 **Higher-Order Components**，简称为 **HOC**
  - 官方的定义：**高阶组件是参数为组件，返回值为新组件的函数**
- 我们可以进行如下的解析：
  - 首先， 高阶组件 本身不是一个组件，而是一个函数；
  - 其次，这个函数的参数是一个组件，返回值也是一个组件；

### 高阶组件的定义方式


```js
// 高阶函数的编写过程类似于这样
function enhanceComponent(WrappedComponent) {
  class NewComponent extends PureComponent {
    render() {
      return <WrappedComponent {...this.props} />;
    }
  }

  NewComponent.displayName = 'NewApp';
  return NewComponent;
}

// 高阶组件的调用过程类似于这样
const EnhanceComponent = enhanceComponent(App);
```

高阶组件并不是React API的一部分，它是基于React的组合特性而形成的设计模式；

#### 组件的名称问题

- 在ES6中，类表达式中类名是可以省略的；
- 组件的名称都可以通过displayName来修改；

```js
NewComponent.displayName = 'NewApp';
```

### 高阶函数的意义

利用高阶组件可以针对某些React代码进行更加优雅的处理

- HOC的一些缺陷(不足)：
  - HOC需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，这让调试变得非常困难；
  - HOC可以劫持props，在不遵守约定的情况下也可能造成冲突

- Hook的出现，是开创性的，它解决了很多React之前的存在的问题
  - 比如this指向问题、比如hoc的嵌套复杂度问题等等；

