---
title: React中的样式
date: 2021-12-14 18:54:52
permalink: /pages/33b323/
categories:
  - react
  - React核心语法
tags:
  - 
---
## 组件化下的CSS

- 目前整个前端已经是组件化的天下：
  - 而CSS的设计就不是为组件化而生的，所以在目前组件化的框架中都在需要一种合适的CSS解决方案。
- 在组件化中选择合适的CSS解决方案应该符合以下条件：
  - 可以编写局部css：css具备自己的具备作用域，不会随意污染其他组件内的原生；
  - 可以编写动态的css：可以获取当前组件的一些状态，根据状态的变化生成不同的css样式；
  - 支持所有的css特性：伪类、动画、媒体查询等；
  - 编写起来简洁方便、最好符合一贯的css风格特点；
  - 等等...

<!-- more -->

## React中的CSS

- Vue中的css方案
  - Vue通过在.vue文件中编写 `<style><style>` 标签来编写自己的样式
  - 通过是否添加 `scoped` 属性来决定编写的样式是全局有效还是局部有效
  - 通过 `lang` 属性来设置你喜欢的 less、sass等预处理器
  - 通过内联样式风格的方式来根据最新状态设置和改变css

- React官方并没有给出在React中统一的样式风格
  - 由此，从普通的css，到css modules，再到css in js，有几十种不同的解决方案，上百个不同的库；
  - 大家一致在寻找最好的或者说最适合自己的CSS方案，但是到目前为止也没有统一的方案

- 本文介绍以下几种css方案
  - 内联样式
  - 普通的css
  - css modules
  - CSS in JS
    - styled-components(库)
  - 添加class
    - classnames(库)

## 内联样式

- 内联样式是官方推荐的一种css样式的写法：
  - style 接受一个采用小驼峰命名属性的 JavaScript 对象，，而不是 CSS 字符串；
  - 并且可以引用state中的状态来设置相关的样式；
- 内联样式的优点:
  - 1.内联样式, 样式之间不会有冲突
  - 2.可以动态获取当前state中的状态
- 内联样式的缺点：
  - 1.写法上都需要使用驼峰标识
  - 2.某些样式没有提示
  - 3.大量的样式, 代码混乱
  - 4.某些样式无法编写(比如伪类/伪元素)

```js
import React, { PureComponent } from 'react';

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      color: 'Aqua',
    };
  }

  render() {
    const pStyle = {
      color: this.state.color,
      textDecoration: 'underline',
    };

    return (
      <div>
        <h2 style={{ 'font-size': '20px', color: 'red' }}>
          我是标题 'font-size': '20px', color: 'red' Unsupported
        </h2>

        <h2 style={{ fontSize: '30px', color: 'blue' }}>
          我是标题 fontSize: '50px', color: 'blue'
        </h2>

        <p style={pStyle}>我是一段文字描述</p>
      </div>
    );
  }
}
```

## 普通的css

- 普通的css我们通常会编写到一个单独的文件，之后再进行引入。
- 这样的编写方式和普通的网页开发中编写方式是一致的：
  - 如果我们按照普通的网页标准去编写，那么也不会有太大的问题；
  - 但是组件化开发中我们总是希望组件是一个独立的模块，即便是样式也只是在自己内部生效，不会相互影响；
  - 但是普通的css都属于**全局**的css，样式之间会相互影响；
- 这种编写方式最大的问题是样式之间会相互层叠掉；

普通的css demo链接跳转 - 待添加

## css modules

- css modules并不是React特有的解决方案，而是所有使用了类似于webpack配置的环境下都可以使用的
  - 但是，如果在其他项目中使用个，那么我们需要自己来进行配置，比如配置`webpack.config.js中的modules: true`等
- React的脚手架已经内置了css modules的配置：
  - `.css/.less/.scss` 等样式文件都修改成 `.module.css/.module.less/.module.scss` 等
  - 之后就可以引用并且进行使用了
- css modules确实解决了局部作用域的问题，也是很多人喜欢在React中使用的一种方案
- 但是这种方案也有自己的缺陷：
  - 引用的类名，不能使用连接符`(.home-title)`，**中横线 ( - )** 在JavaScript中是不识别的
  - 所有的className都必须使用`{style.className}` 的形式来编写
  - 不方便动态来修改某些样式，依然需要使用内联样式的方式

```js
import React, { PureComponent } from 'react';

import appStyle from './style.module.css';

import Home from '../home';
import Profile from '../profile';

export default class App extends PureComponent {
  render() {
    return (
      <div id="app">
        App
        <h3 className={appStyle.title}>我是App的title</h3>
        <hr />
        <Home />
        <hr />
        <Profile />
      </div>
    );
  }
}
```

## CSS in JS

- React官方文档也有提到过CSS in JS这种方案：
  - “CSS-in-JS” 是指一种模式，其中 CSS 由 JavaScript 生成而不是在外部文件中定义；
  - 注意此功能并不是 React 的一部分，而是由第三方库提供。 React 对样式如何定义并没有明确态度；
- 在传统的前端开发中，我们通常会将**结构**（HTML）、**样式**（CSS）、**逻辑**（JavaScript）进行分离。
  - 但是在前面的学习中，我们就提到过，React的思想中认为逻辑本身和UI是无法分离的，所以才会有了JSX的语法。
  - 样式呢？样式也是属于UI的一部分；
  - 事实上CSS-in-JS的模式就是一种将样式（CSS）也写入到JavaScript中的方式，并且可以方便的使用JavaScript的状态；
  - 所以React有被人称之为 `All in JS`

### styled-components

- 很多优秀的CSS-in-JS的库依然非常强大、方便：
  - CSS-in-JS通过JavaScript来为CSS赋予一些能力，包括类似于CSS预处理器一样的样式嵌套、函数定义、逻辑复用、动态修改状态等等；
  - 依然CSS预处理器也具备某些能力，但是获取动态状态依然是一个不好处理的点；
  - 所以，目前可以说CSS-in-JS是React编写CSS最为受欢迎的一种解决方案；
- 目前比较流行的`CSS-in-JS`的库有哪些呢？
  - [styled-components](https://www.npmjs.com/package/styled-components)
  - [emotion](https://www.npmjs.com/package/emotion)
  - [Stylelint](https://www.npmjs.com/package/stylelint)
  - [更多...](https://www.npmjs.com/search?q=keywords:css-in-js)
- 目前可以说`styled-components`依然是社区最流行的CSS-in-JS库
- 安装styled-components： `yarn add styled-components`

#### styled的基本使用

- styled-components的本质是通过函数的调用，最终创建出一个组件
  - 这个组件会被自动添加上一个不重复的class
  - styled-components会给该class添加相关的样式
- 另外，它支持类似于CSS预处理器一样的样式嵌套
  - 支持直接子代选择器或后代选择器，并且直接编写样式
  - 可以通过`&符号`获取当前元素
  - 直接`伪类选择器`、`伪元素`等

```js
import React, { PureComponent } from 'react';

import styled from 'styled-components';

export const HomeWrapper = styled.div`
  font-size: 12px;
  color: red;

  .banner {
    background-color: blue;

    span {
      color: #fff;

      &.active {
        color: #f00;
      }

      &:hover {
        color: green;
      }

      &::after {
        content: 'aaa';
      }
    }

    /* .active {
      color: #f00;
    } */
  }
`;

export default class Home extends PureComponent {
  render() {
    return (
      <HomeWrapper>
        <TitleWrapper>我是home的标题</TitleWrapper>
        <div className="banner">
          <span>轮播图1</span>
          <span className="active">轮播图2</span>
          <span>轮播图3</span>
          <span>轮播图4</span>
        </div>
      </HomeWrapper>
    );
  }
}
```

#### props、attrs属性

- props可以穿透
- props可以被传递给styled组件
  - 获取props需要通过`${}`传入一个插值函数，props会作为该函数的参数；
  - 这种方式可以有效的解决动态样式的问题；
- 添加attrs属性

```js
import React, { PureComponent } from 'react';

import styled from 'styled-components';

/**
 * 特点:
 *  1.props穿透
 *  2.attrs的使用
 *  3.传入state作为props属性
 */

const IOInput = styled.input.attrs({
  placeholder: 'momo placeholder',
  bColor: 'red',
})`
  background-color: lightgreen;
  border-color: ${(props) => props.bColor};
  color: ${(props) => props.color};
`;

export default class Profile extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      color: 'purple',
    };
  }

  render() {
    return (
      <div>
        <input type="password" />
        <IOInput type="text" color={this.state.color} />
        <h2 style={{ color: this.state.color }}>我是Profile的标题</h2>
        <ul>
          <li>设置列表1</li>
          <li>设置列表2</li>
          <li>设置列表3</li>
        </ul>
      </div>
    );
  }
}
```

#### styled高级特性

- 支持样式的继承

```js
const IOButton = styled.button`
  padding: 10px 20px;
  border-color: red;
  color: red;
`;

// const IOPrimaryButton = styled.button`
//   padding: 10px 20px;
//   border-color: red;

//   color: #fff;
//   background-color: green;
// `;

const IOPrimaryButton = styled(IOButton)`
  color: #fff;
  background-color: green;
`;
```

- styled设置主题

```js
import { ThemeProvider } from 'styled-components';

<ThemeProvider theme={{ themeColor: 'Chartreuse', fontSize: '30px' }}>
  App
  <h3>我是App的title</h3>
  <hr />
  <Home />
  <hr />
  <Profile />
</ThemeProvider>
```

## 添加class

### vue中添加class

- vue中添加class是一件非常简单的事情：

- 你可以通过传入一个对象：

```vue
<div class='static'
     v-bind:class="{ active : isActive, 'text-danger' : hasError}">
</div>
```

- 你也可以传入一个数组：

```vue
<div v-bind:class="[activeClass, errorClass]"></div>
```

- 甚至是对象和数组混合使用：

```vue
<div v-bind:class="[{ active : isActive}, errorClass]"></div>
```

### React中添加class

- React在JSX给了我们开发者足够多的灵活性，你可以像编写JavaScript代码一样，通过一些逻辑来决定是否添加某些class：

```js
{/* 原生React中添加class的三种方法 */}
<h2 className={'bor bar active title'}>我是标题1</h2> {/* bor bar active title */}
<h2 className={'title ' + (isActive ? 'active' : '')}>我是标题2</h2> {/* title active */}
<h2 className={['title', isActive ? 'active' : ''].join(' ')}> {/* title active */}
  我是标题3
</h2>
```

- 这个时候我们可以借助于一个第三方的库：`classnames` 一个用于动态添加classnames的一个库

```js
import React, { PureComponent } from 'react';

import classNames from 'classnames';

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      isActive: true,
    };
  }

  render() {
    const { isActive } = this.state;
    const isBar = false;
    const errClass = 'error';
    const warnClass = 10;

    return (
      <div>
        {/* 通过classnames库添加class */}
        <h2 className="foo bar active title">我是标题4</h2>  {/* foo bar active title */}
        <h2 className={classNames('foo', 'bar', 'active', 'title')}> {/* foo bar active title */}
          我是标题5
        </h2>
        <h2 className={classNames({ active: isActive, bar: isBar }, 'title')}> {/* active title */}
          我是标题6
        </h2>
        <h2
          className={classNames('foo', errClass, warnClass, {
            active: isActive,
          })}> {/* foo error 10 active */}
          我是标题7
        </h2>
        <h2 className={classNames(['active', 'title'])}>我是标题8</h2> {/* active title */}
        <h2 className={classNames(['active', 'title', { bar: isBar }])}> {/* active title */}
          我是标题9
        </h2>
      </div>
    );
  }
}
```
