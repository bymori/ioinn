---
title: 网络请求和封装
date: 2021-12-15 10:34:49
permalink: /pages/0d95d0/
categories:
  - react
  - React核心语法
tags:
  - axios
---
## 前端网络请求的选择

- 目前前端中发送网络请求的方式有很多种

1. 传统的Ajax -基于XMLHttpRequest(XHR)
2. jQuery AJAX
3. Fetch API
4. Axios

简单介绍几种网络请求方式优缺点及详解Axios
<!-- more -->

### 传统的Ajax

**为什么不用它呢?**

- 非常好解释, 配置和调用方式等非常混乱.
- 编码起来看起来就非常蛋疼.
- 所以真实开发中很少直接使用, 而是使用jQuery AJAX

### jQuery AJAX

- 相对于传统的Ajax非常好用

**为什么不选择它呢？**

- jQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）
- 基于原生的XHR开发，XHR本身的架构不清晰，已经有了`Fetch`的替代方案；
- 尽管JQuery对我们前端的开发工作曾有着深远的影响，但是的确正在推出历史舞台

### Fetch API

**选择或者不选择它?**

- Fetch是AJAX的替换方案，基于Promise设计，很好的进行了关注分离，有很大一批人喜欢使用fetch进行项目开发
- 但是Fetch的缺点也很明显，首先需要明确的是Fetch是一个 low-level（底层）的API，没有帮助你封装好各种各样的功能和实现
- 比如发送网络请求需要自己来配置Header的Content-Type，不会默认携带cookie等
- 比如错误处理相对麻烦（只有网络错误才会reject，HTTP状态码404或者500不会被标记为reject）
- 比如不支持取消一个请求，不能查看一个请求的进度等等
- MDN Fetch学习地址：[https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch)

### Axios

- axios是目前前端使用非常广泛的网络请求库，包括Vue作者也是推荐在vue中使用axios
- 主要特点包括：在浏览器中发送 XMLHttpRequests 请求、在 node.js 中发送 http请求、支持 Promise API、拦截请求和响应、转换请求和响应数据等等
  - axios: ajax i/o system

## Axios的基本使用

- 支持多种请求方式

```js
axios(config)
axios(url[, config])
axios.request(config)
axios.get(url[, config])
axios.delete(url[, config])
axios.head(url[, config])
axios.options(url[, config])
axios.post(url[, data[, config]])
axios.put(url[, data[, config]])
axios.patch(url[, data[, config]])
```

使用 [httpbin.org](http://httpbin.org/) 这个网站来测试发送请求

## axios发送请求

- 直接通过axios函数发送请求
- 发送get请求
- 发送post请求
- 多个请求的合并
- 使用async、await发送请求
  
- axios函数、get、post请求本质上都是request请求

## axios API

可以通过将相关配置传递给axios来发出请求

### axios(config)

```js
axios({
  url: 'https://httpbin.org/get',
  params: {
    name: 'momo',
    age: 19,
  },
})
  .then((res) => {
    console.log(res);
  })
  .catch((err) => {
    console.error(err);
  });

  // 发送POST请求
axios({
  url: 'https://httpbin.org/post',
  data: {
    name: 'mori',
    age: 29,
  },
  method: 'post',
})
  .then((res) => {
    console.log(res);
  })
  .catch((err) => {
    console.error(err);
  });
    
```

### axios(url[, config])

```js
// 发送GET请求(默认方法)
axios('/user/12345');
```

### axios.get(url[, config])

```js
axios
  .get('https://httpbin.org/get', {
    params: {
      name: 'momo',
      age: 30,
    },
  })
  .then(console.log);
```

### axios.post(url[, data[, config]])

```js
axios
  .post('https://httpbin.org/post', {
    name: 'Ford',
    age: 28,
  })
  .then(console.log);
```

### axios的配置信息

1. 请求配置选项
2. 响应结构信息
3. 全局默认配置

```js
axios.defaults.baseURL = 'https://httpbin.org';
axios.defaults.timeout = 5000;
axios.defaults.headers.common['token'] = 'tokentokentoken';
```

4. 自定义实例默认配置

```js
// 区分开发与生产环境，加载不同的配置
const devBaseURL = 'https://httpbin.org';
const proBaseURL = 'https://api.ioinn.cn';
export const BASE_URL =
  process.env.NODE_ENV === 'development' ? devBaseURL : proBaseURL;

export const TIMEOUT = 5000;

// 使用
const instance = axios.create({
  baseURL: BASE_URL,
  timeout: TIMEOUT,
});
```

- 优先是请求的config参数配置
- 其次是实例的default中的配置
- 最后是创建实例时的配置

## axios拦截器

axios库有一个非常好用的特性是可以添加拦截器

- 请求拦截器：在发送请求时，请求被拦截
  - 发送网络请求时，在页面中添加一个loading组件作为动画
  - 某些网络请求要求用户必须登录，可以在请求中判断是否携带了token，没有携带token直接跳转到login页面
  - 对某些请求参数进行序列化

```js
// 添加 请求拦截器
instance.interceptors.request.use(function (config) {
    // 在发送请求之前执行某些操作
    // 1.发送网络请求时, 在界面的中间位置显示Loading的组件
    // 2.某一些请求要求用户必须携带token, 如果没有携带, 那么直接跳转到登录页面
    // 3.params/data序列化的操作

    console.log('请求被拦截');
    return config;
  }, function (error) {
    // 对请求错误执行某些操作
    return Promise.reject(error);
  });

```

- 响应拦截器：在响应结果中，结果被拦截
  - 响应拦截中可以对结果进行二次处理（比如服务器真正返回的数据其实是在response的data中）
  - 对于错误信息进行判断，根据不同的状态进行不同的处理

```js
// 添加 响应拦截器
instance.interceptors.response.use(function (response) {
    // 位于2xx范围内的任何状态代码都会触发此函数
    // 对响应数据采取一些措施
    return response;
  }, function (error) {
    // 超出2xx范围的任何状态代码都会触发此函数
    // 对响应错误采取措施
    return Promise.reject(error);
  });
```

最后返回 `instance` 就可以了

### 为什么要二次封装

**为什么要对axios进行二次封装呢？**

- 默认情况下我们是可以直接使用axios来进行开发的；
- 但是我们考虑一个问题，假如有100多处中都直接依赖axios，突然间有一天axios出现了重大bug，并且该库已经不再维护，这个时候如何处理呢？
- 大多数情况下我们会寻找一个新的网络请求库或者自己进行二次封装；
- 但是有100多处都依赖了axios，方便我们进行修改吗？我们所有依赖axios库的地方都需要进行修改

