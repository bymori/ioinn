---
title: 表单处理和ref
date: 2021-12-15 16:16:18
permalink: /pages/134ac0/
categories:
  - react
  - React核心语法
tags:
  - ref
  - 表单绑定
---
## 受控和非受控组件

### refs的使用

- 在React的开发模式中，通常情况下不需要、也不建议直接操作DOM原生，但是某些特殊的情况，确实需要获取到DOM进行某些操作：
  - 管理焦点，文本选择或媒体播放；
  - 触发强制动画；
  - 集成第三方 DOM 库

<!-- more -->

- 如何创建`refs`来获取对应的DOM呢？目前有三种方式
- 方式一：传入字符串
  - 使用时通过 this.refs.传入的字符串格式获取对应的元素；
- 方式二：传入一个对象
  - 对象是通过 React.createRef() 方式创建出来的；
  - 使用时获取到创建的对象其中有一个current属性就是对应的元素；
- 方式三：传入一个函数
  - 该函数会在DOM被挂载时进行回调，这个函数会传入一个 元素对象，我们可以自己保存；
  - 使用时，直接拿到之前保存的元素对象即可；

#### ref的类型

- ref 的值根据节点的类型而有所不同：
  - 当 ref 属性用于 HTML 元素时，构造函数中使用 `React.createRef()` 创建的 ref 接收底层 DOM 元素作为其 current 属性；
  - 当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性；
  - 你**不能**在**函数组件**上使用 ref 属性，因为他们没有实例；

- 函数式组件是没有实例的，所以无法通过ref获取他们的实例：
  - 但是某些时候，我们可能想要获取函数式组件中的某个DOM元素；
  - 这个时候我们可以通过 `React.forwardRef` ，后面学习 hooks 中如何使用ref；

```js
import React, { PureComponent, createRef } from 'react';

class Counter extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0,
    };
  }

  render() {
    return (
      <div>
        <h2>Counter组件 : 当前计数: {this.state.counter}</h2>
        <button onClick={(e) => this.increment()}>+1</button>
      </div>
    );
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1,
    });
  }
}

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.titleRef = createRef();
    this.counterRef = createRef();
    this.titleEl = null;
  }

  render() {
    return (
      <div>
        {/* <h2 ref=字符串/对象/函数>Hello React</h2> */}
        <h2 ref="titleRef">Hello React</h2>
        <button onClick={(e) => this.changeTextOne()}>改变文本 一</button>

        {/* 目前React推荐的方式 */}
        <h2 ref={this.titleRef}>Hello React titleRef</h2>
        <button onClick={(e) => this.changeTextTwo()}>改变文本 二</button>

        {/* 回调函数方式 */}
        <h2 ref={(arg) => (this.titleEl = arg)}>Hello React</h2>
        <button onClick={(e) => this.changeTextThree()}>改变文本 三</button>

        <Counter ref={this.counterRef} />
        <button onClick={(e) => this.appBtnClick()}>App按钮</button>
      </div>
    );
  }

  changeTextOne() {
    // 1.使用方式一: 字符串(不推荐, refs 已废弃 21.11.30)
    this.refs.titleRef.innerHTML = 'Hello momo';
  }

  changeTextTwo() {
    // 2.使用方式二: 对象方式
    this.titleRef.current.innerHTML = 'Hello JavaScript';
  }

  changeTextThree() {
    // 3.使用方式三: 回调函数方式
    this.titleEl.innerHTML = 'Hello TypeScript';
  }

  //   注意 不能在函数组件上使用ref属性，因为他们没有实例；
  appBtnClick() {
    this.counterRef.current.increment();
  }
}
```

### 受控组件的基本使用

在React中，HTML表单的处理方式和普通的DOM元素不太一样：表单元素通常会保存在一些内部的state

- 比如下面的HTML表单元素：
  - 这个处理方式是DOM默认处理HTML表单的行为，在用户点击提交时会提交到某个服务器中，并且刷新页面；
  - 在React中，并没有禁止这个行为，它依然是有效的；
  - 但是通常情况下会使用JavaScript函数来方便的处理表单提交，同时还可以访问用户填写的表单数据；
  - 实现这种效果的标准方式是使用“受控组件”

```js
<form>
  <label>
    用户: <input type="text" name="username" />
  </label>
  <input type="submit" value="提交" />
</form>
```

- 在 HTML 中，表单元素（如`<input>`、 `<textarea>` 和 `<select>`）之类的表单元素通常自己维护 state，并根据用户输入进行更新。
- 而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。
  - 我们将两者结合起来，使React的state成为“唯一数据源”；
  - 渲染表单的 React 组件还控制着用户输入过程中表单发生的操作；
  - 被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”；
- 由于在表单元素上设置了 value 属性，因此显示的值将始终为 `this.state.value`，这使得 React 的 state 成为唯一数据源。
- 由于 handleChange 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。

```js
import React, { PureComponent } from 'react';

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      username: '',
    };
  }

  render() {
    return (
      <div>
        <form onSubmit={(e) => this.handleSubmit(e)}>
          <label htmlFor="username">
            用户: {/* 受控组件 */}
            <input
              type="text"
              id="username"
              onChange={(e) => this.handleChange(e)}
              value={this.state.username}
            />
          </label>
          <input type="submit" value="提交" />
        </form>
      </div>
    );
  }

  handleSubmit(event) {
    event.preventDefault();
    // console.log(event);
    console.log(this.state.username);
  }

  handleChange(event) {
    console.log(event.target.value);
    this.setState({
      username: event.target.value,
    });
  }
}
```

### 非受控组件

- React推荐大多数情况下使用 受控组件 来处理表单数据：
  - 一个受控组件中，表单数据是由 React 组件来管理的；
  - 另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理；
- 如果要使用非受控组件中的数据，那么我们需要使用 ref 来从DOM节点中获取表单数据。
- 在非受控组件中通常使用`defaultValue`来设置默认值；
- 同样，`<input type="checkbox">` 和 `<input type="radio">` 支持 `defaultChecked`，`<select>` 和 `<textarea>` 支持 `defaultValue`

```js
import React, { PureComponent, createRef } from 'react';

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.usernameRef = createRef();
  }

  render() {
    return (
      <div>
        <form onSubmit={(e) => this.handleSubmit(e)}>
          <label htmlFor="username">
            用户:
            <input type="text" id="username" ref={this.usernameRef} />
          </label>
          <input type="submit" value="提交" />
        </form>
      </div>
    );
  }

  handleSubmit(event) {
    event.preventDefault();
    console.log(this.usernameRef.current.value);
  }
}
```

### ref的转发

- ref不能应用于函数式组件：因为函数式组件没有实例，所以不能获取到对应的组件对象
  - 但是，在开发中我们可能想要获取函数式组件中某个元素的DOM，这个时候我们应该如何操作呢？
- **方式一**：直接传入ref属性（错误的做法）
- **方式二**：通过forwardRef高阶函数

```js
// 高阶组件 forwardRef
const Profile = forwardRef(function (props, ref) {
  return <p ref={ref}>Profile</p>;
});
```