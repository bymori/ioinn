---
title: hooks进阶
date: 2021-12-17 21:39:59
permalink: /pages/b77136/
categories:
  - react
  - React Hooks
tags:
  - 
---
## hooks进阶使用

本篇介绍 `useContext` `useRef` `useImperativeHandle` `useMemo` `useCallback` `useLayoutEffect` `useDebugValue` 等hook
<!-- more -->

## useContext的使用

在之前的开发中，我们要在组件中使用共享的Context有两种方式：

- 类组件可以通过 `类名.contextType = MyContext`方式，在类中获取context；
- 多个Context或者在函数式组件中通过 `MyContext.Consumer` 方式共享context；

但是多个Context共享时的方式会**存在大量的嵌套**：

- `Context Hook`允许我们通过Hook来直接获取某个Context的值；

```js
// App.js
export const UserContext = createContext();
export const ThemeContext = createContext();

export default function App() {
  return (
    <div>
      <UserContext.Provider value={{ name: 'momo', age: 19 }}>
        <ThemeContext.Provider value={{ fontSize: '30px', color: 'red' }}>
          <ContextHookDemo />
        </ThemeContext.Provider>
      </UserContext.Provider>
    </div>
  )
}

// useContext的使用.js
import React, { useContext } from 'react';

import { UserContext, ThemeContext } from '../App';

export default function ContextHookDemo() {
  const user = useContext(UserContext);
  const theme = useContext(ThemeContext);

  console.log(user, theme);

  return (
    <div>
      <h2>ContextHookDemo</h2>
    </div>
  );
}
```

**注意事项**：

- 当组件上层最近的 `<MyContext.Provider>` 更新时，该 Hook 会触发重新渲染，并使用最新传递给 MyContext provider 的 context value 值

## useReducer

很多人看到useReducer的第一反应应该是redux的某个替代品，其实**并不是**

useReducer仅仅是useState的一种替代方案：

- 在某些场景下，如果state的处理逻辑比较复杂，我们可以通过useReducer来对其进行拆分
- 或者这次修改的state需要依赖之前的state时，也可以使用

```js
// reducer.js
export default function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { ...state, counter: state.counter + 1 };
    case 'decrement':
      return { ...state, counter: state.counter - 1 };
    default:
      return state;
  }
}


// home  profile 相同逻辑
import React, { useState, useReducer } from 'react';

import reducer from './reducer';

export default function Home() {
  //   const [count, setCount] = useState(0);
  const [state, dispatch] = useReducer(reducer, { counter: 0 });

  return (
    <div>
      <h2>Home当前计数: {state.counter}</h2>
      <button onClick={(e) => dispatch({ type: 'increment' })}>+1</button>
      <button onClick={(e) => dispatch({ type: 'decrement' })}>-1</button>
    </div>
  );
}
```

数据是**不会共享**的，它们只是使用了相同的counterReducer的函数而已

- 所以，**useReducer只是useState的一种替代品**，并不能替代Redux

## useCallback

useCallback实际的目的是为了进行**性能的优化**

如何进行性能的优化呢？

- `useCallback`会返回一个函数的 `memoized（记忆的）` 值
- 在依赖不变的情况下，多次定义的时候，返回的值是相同的

```js
  const memoizedCallback = useCallback(() => {
    doSomething(a, b);
  }, [a, b]);
```

**案例**

- 案例一：使用useCallback和不使用useCallback定义一个函数是否会带来性能的优化

```js
// useCallback不能进行的性能优化

import React, { useState, useCallback, useMemo } from 'react';

export default function CallbackHookDemo01() {
  const [count, setCount] = useState(0);

  const increment1 = () => {
    console.log('执行increment1函数');
    setCount(count + 1);
  };

  const increment2 = useCallback(() => {
    console.log('执行increment2函数');
    setCount(count + 1);
  }, [count]);

  return (
    <div>
      <h2>CallbackHookDemo01: {count}</h2>
      <button onClick={increment1}>+1</button>
      <button onClick={increment2}>+1</button>
    </div>
  );
}
```

- 案例二：使用useCallback和不使用useCallback定义一个函数传递给子组件是否会带来性能的优化

```js
// useCallback进行的性能优化

import React, { useState, useCallback, memo } from 'react';

/**
 * useCallback在什么时候使用?
 * 场景: 在将一个组件中的函数, 传递给子元素进行回调使用时, 使用useCallback对函数进行处理.
 */

const IOButton = memo((props) => {
  console.log('IOButton重新渲染: ' + props.title);

  return <button onClick={props.increment}>+1</button>;
});

export default function CallbackHookDemo02() {
  console.log('CallbackHookDemo02重新渲染');

  const [count, setCount] = useState(0);
  const [show, setShow] = useState(true);

  const increment1 = () => {
    console.log('执行increment1函数');
    setCount(count + 1);
  };

  const increment2 = useCallback(() => {
    console.log('执行increment2函数');
    setCount(count + 1);
  }, [count]);

  return (
    <div>
      <h2>CallbackHookDemo02: {count}</h2>
      {/* <button onClick={increment1}>+1</button>
      <button onClick={increment2}>+1</button> */}
      <IOButton title="btn1" increment={increment1} />
      <IOButton title="btn2" increment={increment2} />

      <button onClick={(e) => setShow(!show)}>show切换</button>
    </div>
  );
}
```

通常使用`useCallback`的目的是不希望子组件进行多次渲染，并不是为了函数进行缓存

## useMemo

useMemo实际的目的也是为了进行**性能的优化**

**如何进行性能的优化呢**？

- `useMemo`返回的也是一个 `memoized（记忆的）` 值；
- 在依赖不变的情况下，多次定义的时候，返回的值是相同的；

```js
  const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

**案例**：

- 案例一：进行大量的计算操作，是否有必须要每次渲染时都重新计算

```js
import React, { useState, useMemo } from 'react';

function calcNumber(count) {
  console.log('calcNumber重新计算');

  let total = 0;
  for (let i = 0; i <= count; i++) {
    total += i;
  }
  return total;
}

export default function MemoHookDemo01() {
  const [count, setCount] = useState(10);
  const [show, setShow] = useState(true);

  //   const total = calcNumber(count);
  const total = useMemo(() => {
    return calcNumber(count);
  }, [count]);

  return (
    <div>
      <h2>
        计算数字的和: {total}
        <br />
        count为: {count}
      </h2>
      <button onClick={(e) => setCount(count + 1)}>+1</button>
      <button onClick={(e) => setShow(!show)}>show切换</button>
    </div>
  );
}
```

- 案例二：对子组件传递相同内容的对象时，使用useMemo进行性能的优化

```js
import React, { memo, useState, useMemo } from 'react';

const IOInfo = memo((props) => {
  console.log('IOInfo重新渲染');

  return (
    <h2>
      名字: {props.info.name} 年龄: {props.info.age}
    </h2>
  );
});

export default function MemoHookDemo02() {
  console.log('MemoHookDemo02重新渲染');
  const [show, setShow] = useState(true);

  //   const info = { name: 'momo', age: 19 };
  const info = useMemo(() => {
    return { name: 'momo', age: 19 };
  }, []);

  return (
    <div>
      <IOInfo info={info} />
      <button onClick={(e) => setShow(!show)}>show切换</button>
    </div>
  );
}
```

## useRef

useRef返回一个ref对象，返回的ref对象再组件的整个生命周期保持不变。

**最常用的ref是两种用法**：

- 用法一：引入DOM（或者组件，但是需要是class组件）元素
- 用法二：保存一个数据，这个对象在整个生命周期中可以保存不变

```js
const refContainer = useRef(initialValue);
```

**案例**：

- 案例一：引用DOM

```js
import React, { useRef } from 'react';

class TestCpn extends React.Component {
  render() {
    return <h2>TestCpn</h2>;
  }
}

function TestCpn2(props) {
  return <h2>TestCpn2</h2>;
}

export default function RefHookDemo01() {
  // const refContainer = useRef(initialValue);

  const titleRef = useRef();
  const inputRef = useRef();

  const testRef = useRef();
  const testRef2 = useRef();

  function changeDOM() {
    titleRef.current.innerHTML = 'Hello World';
    inputRef.current.focus();

    console.log(testRef.current);
    console.log(testRef2.current);
  }

  return (
    <div>
      <h2 ref={titleRef}>RefHookDemo01</h2>
      <input ref={inputRef} type="text" />
      <TestCpn ref={testRef} />
      <TestCpn2 ref={testRef2} />

      <button onClick={(e) => changeDOM()}>修改DOM</button>
    </div>
  );
}
```

- 案例二：使用ref保存上一次的某一个值

```js
import React, { useState, useRef, useEffect } from 'react';

export default function RefHookDemo02() {
  const [count, setCount] = useState(0);

  const numRef = useRef(count);

  useEffect(() => {
    numRef.current = count;
  }, [count]);

  return (
    <div>
      <h2>numRef中的值: {numRef.current}</h2>
      <h2>count中的值: {count}</h2>

      <h3>count上一次的值: {numRef.current}</h3>
      <h3>count这一次的值: {count}</h3>

      <button onClick={(e) => setCount(count + 10)}>+10</button>
    </div>
  );
}
```

## useImperativeHandle

`useImperativeHandle`不是特别好理解

先来回顾一下ref和forwardRef结合使用：

- 通过forwardRef可以将ref转发到子组件
- 子组件拿到父组件中创建的ref，绑定到自己的某一个元素中

forwardRef的做法本身没有什么问题，但是将子组件的DOM直接暴露给了父组件：

- 直接暴露给父组件带来的问题是某些情况的**不可控**
- 父组件可以拿到DOM后进行任意的操作
- 但是，事实上在下面的案例中，我们只是希望父组件可以操作的focus，其他并**不希望它随意操作**

```js
import React, { useRef, forwardRef } from 'react';

const IOInput = forwardRef((props, ref) => {
  return <input ref={ref} type="text" />;
});

export default function ForwardRefDemo() {
  const inputRef = useRef();

  return (
    <div>
      <IOInput ref={inputRef} />
      <button onClick={(e) => inputRef.current.focus()}>聚焦</button>
    </div>
  );
}
```

通过`useImperativeHandle`可以只**暴露固定的操作**：

- `useImperativeHandle(ref, createHandle, [deps])`
- 通过`useImperativeHandle`的Hook，将传入的ref和`useImperativeHandle`第二个参数返回的对象绑定到了一起
- 所以在父组件中，使用 `inputRef.current`时，实际上使用的是返回的对象
- [useImperativeHandle](https://zh-hans.reactjs.org/docs/hooks-reference.html#useimperativehandle)

```js
import React, { useRef, forwardRef, useImperativeHandle } from 'react';

const IOInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(
    ref,
    () => ({
      focus: () => {
        inputRef.current.focus();
      },
    }),
    [inputRef]
  );

  return <input ref={inputRef} type="text" />;
});

export default function UseImperativeHandleHookDemo() {
  const inputRef = useRef();

  return (
    <div>
      <IOInput ref={inputRef} />
      <button onClick={(e) => inputRef.current.focus()}>聚焦</button>
    </div>
  );
}
```

在本例中，渲染 `<IOInput ref={inputRef} />` 的父组件可以调用 `inputRef.current.focus()`

## useLayoutEffect

`useLayoutEffect`看起来和`useEffect`非常的相似，事实上他们也只有一点区别而已

- `useEffect`会在渲染的内容更新到DOM上后执行，**不会**阻塞DOM的更新
- `useLayoutEffect`会在渲染的内容更新到DOM上之前执行，**会**阻塞DOM的更新
- React官方建议尽可能使用标准的 `useEffect` 以避免阻塞视觉更新
- [useLayoutEffect](https://zh-hans.reactjs.org/docs/hooks-reference.html#uselayouteffect)

如果希望在某些操作发生之后再更新DOM，那么应该将这个操作放到`useLayoutEffect`中

**案例**： useEffect和useLayoutEffect的对比

```js
// useEffect
import React, { useState, useEffect } from 'react';

export default function EffectCounterDemo() {
  const [count, setCount] = useState(10);

  useEffect(() => {
    if (count === 0) {
      setCount(Math.random() + 200);
    }
  }, [count]);

  return (
    <div>
      <h2>数字: {count}</h2>
      <button onClick={(e) => setCount(0)}>修改数字</button>
    </div>
  );
}

// useLayoutEffect
import React, { useState, useEffect, useLayoutEffect } from 'react';

export default function LayoutEffectCounterDemo() {
  const [count, setCount] = useState(10);

  useLayoutEffect(() => {
    if (count === 0) {
      setCount(Math.random() + 200);
    }
  }, [count]);

  return (
    <div>
      <h2>数字: {count}</h2>
      <button onClick={(e) => setCount(0)}>修改数字</button>
    </div>
  );
}
```

## useDebugValue

```js
useDebugValue(value)
```

`useDebugValue` 可用于在 **React 开发者工具**中显示自定义 hook 的标签。

```js
function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  // ...

  // 在开发者工具中的这个 Hook 旁边显示标签
  // e.g. "FriendStatus: Online"
  useDebugValue(isOnline ? 'Online' : 'Offline');

  return isOnline;
}
```

提示:**不推荐**你向每个自定义 Hook 添加 debug 值。当它作为共享库的一部分时才最有价值。

**延迟格式化 debug 值**
在某些情况下，格式化值的显示可能是一项开销很大的操作。除非需要检查 Hook，否则没有必要这么做。

因此，`useDebugValue` 接受一个格式化函数作为可选的第二个参数。该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。

例如，一个返回 `Date` 值的自定义 Hook 可以通过格式化函数来避免不必要的 `toDateString` 函数调用：

```js
useDebugValue(date, date => date.toDateString());
```