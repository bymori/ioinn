---
title: hooks基本使用
date: 2021-12-17 12:28:22
permalink: /pages/d19730/
categories:
  - react
  - React Hooks
tags:
  - 
---
在上面介绍 函数式组件结合hooks 中使用了一个hook `useState` 这里详细解析一下

<!-- more -->

## useState解析

```js
import React, { useState } from 'react';

export default function CounterHook() {

    /**
   * Hook: useState
   *  > useState来自react，需要从react中导入，它是一个hook
   *  > 参数和返回值
   *    1.参数: 作用是给创建出来的状态一个默认值 如果不设置为undefined
   *    2.返回值: 数组 包含两个元素
   *      * 元素1: 当前state的值
   *      * 元素2: 设置新的值时,使用的一个函数
   * 
   *  > 点击button按钮后，会完成两件事情：
   *    1.调用setCount，设置一个新的值
   *    2.组件重新渲染，并且根据新的值返回DOM结构
   */

  const [state, setState] = useState(0);

  return (
    <div>
      <h2>当前计数: {state}</h2>
      <button onClick={(e) => setState(state + 1)}>+1</button>
      <button onClick={(e) => setState(state - 1)}>-1</button>
    </div>
  );
}
```

通过上面的一个简单案例，学会Hook的使用了

- Hook 就是 JavaScript 函数，这个函数可以帮助你 钩入（hook into） React State以及生命周期等特性
- 但是使用它们会有两个额外的规则：
  - 只能在函数最外层调用 Hook。**不要**在循环、条件判断或者子函数中调用
  - 只能在 React 的**函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。

提示

- Hook指的类似于useState、useEffect这样的函数
- Hooks是对这类函数的统称

## 认识useState

State Hook的API就是 useState，在前面已经进行了学习：

- **useState**会帮助我们定义一个 state变量，useState 是一种新方法，它与 class 里面的 this.state 提供的功能完全相同。一般来说，在函数退出后变量就会”消失”，而 state 中的变量会被 React 保留
- **useState**接受唯一 一个参数，在第一次组件被调用时使用来作为初始化值。（如果没有传递参数，那么初始化值为`undefined`）
- **useState**是一个**数组**，我们可以通过数组的解构，来完成赋值会非常方便
  - [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

FAQ：为什么叫 `useState` 而不叫 `createState`?

- “Create” 可能不是很准确，因为 state 只在组件首次渲染的时候被创建
- 在下一次重新渲染时，useState 返回给我们当前的 state
- 如果每次都创建新的变量，它就不是 “state”了
- 这也是 Hook 的名字总是以 use 开头的一个原因

当然，也可以在一个组件中定义多个变量和复杂变量（数组、对象）

```js
import React, { useState } from 'react';

export default function MultiHookState() {
  const [count, setCount] = useState(0);
  const [age, setAge] = useState(19);
  const [friends, setFriends] = useState([
    'Naomi',
    'Josephine',
    'Dennis',
    'momo',
  ]);

  return (
    <div>
      <h2>当前计数: {count}</h2>
      <h2>我的年龄: {age}</h2>
      <ul>
        {friends.map((item, index) => {
          return <li key={item}>{item}</li>;
        })}
      </ul>
    </div>
  );
}
```

## 认识Effect Hook

目前我们已经通过hook在函数式组件中定义state，那么类似于生命周期这些呢？

- `Effect Hook` 可以让你来完成一些**类似于class中生命周期**的功能
- 事实上，类似于网络请求、手动更新DOM、一些事件的监听，都是React更新DOM的一些副作用（**Side Effects**）

所以对于完成这些功能的Hook被称之为 **Effect Hook**

假如我们现在有一个需求：页面的title总是显示counter的数字，分别使用class组件和Hook实现：

```js
// class
import React, { PureComponent } from 'react';

export default class ClassCounterTitleChange extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0,
    };
  }

  componentDidMount() {
    // 1.修改DOM
    document.title = 'class ' + this.state.counter;

    // 2.订阅事件
    console.log('订阅一些事件');

    // 3.网络请求
    // 4. ...
  }

  componentWillUnmount() {
    console.log('取消事件订阅');
  }

  componentDidUpdate() {
    document.title = 'class ' + this.state.counter;
  }

  render() {
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button
          onClick={(e) => this.setState({ counter: this.state.counter + 1 })}>
          +1
        </button>
      </div>
    );
  }
}

// useEffect
import React, { useState, useEffect } from 'react';

export default function HookCounterChangeTitle() {
  const [counter, setCounter] = useState(0);

  useEffect(() => {
    document.title = 'Hook ' + counter;
  });

  return (
    <div>
      <h2>当前计数: {counter}</h2>
      <button onClick={(e) => setCounter(counter + 1)}>+1</button>
    </div>
  );
}
```

**useEffect的解析**：

- 通过useEffect的Hook，可以告诉React需要在渲染后执行某些操作
- useEffect要求我们传入一个回调函数，在React执行完更新DOM操作之后，就会回调这个函数
- 默认情况下，无论是第一次渲染之后，还是每次更新之后，都会执行这个 回调函数

### 需要清除Effect

在class组件的编写过程中，某些副作用的代码，需要在`componentWillUnmount`中进行清除：

- 比如我们之前的事件总线或Redux中手动调用subscribe
- 都需要在componentWillUnmount有对应的取消订阅
- Effect Hook通过什么方式来模拟`componentWillUnmount`呢？

useEffect传入的**回调函数A**本身可以有一个返回值，这个返回值是另外一个**回调函数B**：

```js
type EffectCallback = () => (void | (() => void | undefined));

  useEffect(() => {
    console.log('订阅一些事件');

    return () => {
      console.log('取消订阅事件');
    };
  }, []);
```

**为什么要在 effect 中返回一个函数**？

- 这是 effect **可选的**清除机制。每个 effect 都可以返回一个清除函数
- 如此可以将添加和移除订阅的逻辑放在一起
- 它们都属于 effect 的一部分

**React 何时清除 effect**？

- React 会在组件更新和卸载的时候执行清除操作
- 正如之前学到的，effect 在每次渲染的时候都会执行

### 使用多个Effect

使用Hook的其中一个目的就是解决class中生命周期经常将很多的逻辑放在一起的问题：

- 比如网络请求、事件监听、手动修改DOM，这些往往都会放在`componentDidMount`中

使用Effect Hook，我们可以将它们分离到不同的useEffect中：

```js
import React, { useState, useEffect } from 'react';

export default function MultiEffectHookDemo() {
  const [count, setCount] = useState(0);
  const [isLogin, setIsLogin] = useState(true);

  useEffect(() => {
    console.log('修改DOM', count);
  }, [count]);

  useEffect(() => {
    console.log('订阅事件');
  }, []);

  useEffect(() => {
    console.log('网络请求');
  }, []);

  return (
    <div>
      <h2>MultiEffectHookDemo</h2>
      <h2>{count}</h2>
      <button onClick={(e) => setCount(count + 1)}>+1</button>

      <h2>{isLogin ? 'momo' : '未登录'}</h2>
      <button onClick={(e) => setIsLogin(!isLogin)}>
        {!isLogin ? '点我登录' : '点击注销'}
      </button>
    </div>
  );
}
```

Hook 允许我们按照代码的用途分离它们， 而不是像生命周期函数那样：

- React 将按照 effect **声明的顺序依次调用**组件中的每一个 effect；

## Effect性能优化

默认情况下，useEffect的回调函数会在每次渲染时都重新执行，但是这会导致两个问题：

- 某些代码我们只是希望执行一次即可，类似于componentDidMount和componentWillUnmount中完成的事情；（比如网络请求、订阅和取消订阅）
- 另外，多次执行也会导致一定的性能问题

我们如何决定useEffect在什么时候应该执行和什么时候不应该执行呢？

- useEffect实际上有两个参数：
  - 参数一：执行的回调函数
  - 参数二：该useEffect在哪些state发生变化时，才重新执行；（受谁的影响）

案例练习：

```js
  useEffect(() => {
    console.log('修改DOM', count);
  }, [count]);
```

但是，如果一个函数我们不希望依赖任何的内容时，也可以传入一个`空的数组 []`：

```js
  useEffect(() => {
    console.log('订阅事件');
  }, []);
```

- 那么这里的两个回调函数分别对应的就是`componentDidMount`和`componentWillUnmount`生命周期函数了
